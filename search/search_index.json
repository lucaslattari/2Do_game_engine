{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"2Do - Motor de Jogos 2D","text":""},{"location":"#visao-geral","title":"Vis\u00e3o Geral","text":"<p>O 2Do \u00e9 um motor gr\u00e1fico (engine) para desenvolvimento de jogos de plataforma 2D, escrito em Python e criado por Lucas Lattari para fins educacionais. Projetado com foco em simplicidade e extensibilidade, o 2Do oferece uma abordagem modular e intuitiva para a cria\u00e7\u00e3o de jogos de plataforma.</p> <p>O framework est\u00e1 sendo desenvolvido com \u00eanfase em boas pr\u00e1ticas de programa\u00e7\u00e3o e arquitetura limpa, tornando-o ideal tanto para iniciantes que desejam aprender sobre desenvolvimento de jogos quanto para desenvolvedores experientes que buscam uma base s\u00f3lida para seus projetos. Com suporte nativo a recursos como anima\u00e7\u00f5es baseadas em sprites, sistema de f\u00edsica para plataformas e integra\u00e7\u00e3o com o formato TMX do Tiled Map Editor, o 2Do almeja simplificar o processo de cria\u00e7\u00e3o de jogos 2D, mantendo a flexibilidade para personaliza\u00e7\u00e3o.</p>"},{"location":"#arquitetura","title":"Arquitetura","text":"<p>O 2Do segue uma arquitetura modular com componentes bem definidos:</p> <ul> <li>Asset Manager: Centraliza o carregamento e gerenciamento de recursos do jogo, como sprites, tiles e mapas.</li> <li>Entity System: Fornece a base para todos os objetos do jogo, como personagens, itens e plataformas.</li> <li>Input Handler: Gerencia a entrada do usu\u00e1rio de forma configur\u00e1vel, permitindo mapear teclas para a\u00e7\u00f5es espec\u00edficas.</li> <li>Physics System: Implementa colis\u00f5es e movimenta\u00e7\u00e3o para jogos de plataforma, incluindo gravidade e detec\u00e7\u00e3o de colis\u00f5es.</li> <li>Background Manager: Controla elementos de plano de fundo, como rolagem em paralaxe e camadas de fundo.</li> <li>Configuration System: Permite personaliza\u00e7\u00e3o do jogo via arquivos <code>.ini</code>, como resolu\u00e7\u00e3o, volume de \u00e1udio e controles.</li> </ul>"},{"location":"#funcionalidades-principais","title":"Funcionalidades Principais","text":"<ul> <li>Sistema de F\u00edsica para Jogos de Plataforma:</li> <li>Implementa gravidade, colis\u00f5es e movimenta\u00e7\u00e3o dos personagens.</li> <li>Suporta plataformas atravess\u00e1veis, permitindo que o jogador passe por certas plataformas ao pular ou cair.</li> </ul> <ul> <li>Gerenciamento de Assets Baseado em Tiles:</li> <li>Organiza e carrega recursos gr\u00e1ficos usando mapas no formato TMX (Tiled Map Editor).</li> <li>Facilita a cria\u00e7\u00e3o de n\u00edveis com tilesets e camadas.</li> </ul> <ul> <li>Sistema de Anima\u00e7\u00e3o por Sprites:</li> <li>Suporta anima\u00e7\u00f5es fluidas para personagens e objetos, com controle de frames e dura\u00e7\u00f5es.</li> </ul> <ul> <li>Colis\u00f5es Precisas:</li> <li>Detecta e gerencia colis\u00f5es entre diferentes entidades do jogo, como personagens, plataformas e itens.</li> </ul> <ul> <li>Parallax Scrolling para Planos de Fundo:</li> <li>Cria uma sensa\u00e7\u00e3o de profundidade movendo camadas de fundo a diferentes velocidades.</li> </ul> <ul> <li>Sistema de Configura\u00e7\u00e3o Flex\u00edvel:</li> <li>Permite personalizar configura\u00e7\u00f5es de jogo atrav\u00e9s de arquivos <code>.ini</code>, como resolu\u00e7\u00e3o, volume de \u00e1udio e controles.</li> </ul> <ul> <li>Controles Personaliz\u00e1veis:</li> <li>Mapeia entradas de teclado conforme a prefer\u00eancia do usu\u00e1rio, com suporte a teclas configur\u00e1veis.</li> </ul> <ul> <li>Suporte a Tela Cheia:</li> <li>Alterna entre modos de tela cheia e janela com um simples comando.</li> </ul> <ul> <li>Sistema de Logging Integrado:</li> <li>Facilita o rastreamento e depura\u00e7\u00e3o durante o desenvolvimento, com logs detalhados.</li> </ul>"},{"location":"#tecnologias-utilizadas","title":"Tecnologias Utilizadas","text":"<p>O 2Do \u00e9 constru\u00eddo utilizando as seguintes tecnologias:</p> <ul> <li>Python: Linguagem de programa\u00e7\u00e3o base do projeto, conhecida por sua simplicidade e legibilidade.</li> <li>Pygame: Framework para desenvolvimento de jogos 2D, fornecendo ferramentas para gr\u00e1ficos, som e entrada de usu\u00e1rio.</li> <li>PyTMX: Biblioteca para carregamento e manipula\u00e7\u00e3o de mapas no formato TMX, criado pelo Tiled Map Editor.</li> <li>ConfigParser: M\u00f3dulo para leitura e gerenciamento de arquivos de configura\u00e7\u00e3o <code>.ini</code>.</li> </ul>"},{"location":"#requisitos-do-sistema","title":"Requisitos do Sistema","text":"<p>Para executar o 2Do, voc\u00ea precisar\u00e1:</p> <ol> <li>Python 3.x instalado.</li> <li>Depend\u00eancias listadas em <code>requirements.txt</code>:    <code>plaintext    pygame==2.3.0    PyTMX==3.31    autopep8==2.0.2    pycodestyle==2.10.0    tomli==2.0.1</code></li> </ol>"},{"location":"#comecando","title":"Come\u00e7ando","text":""},{"location":"#instalacao","title":"Instala\u00e7\u00e3o","text":"<ol> <li> <p>Clone o reposit\u00f3rio:    <code>bash    git clone [URL_DO_REPOSITORIO]</code></p> </li> <li> <p>Instale as depend\u00eancias:    <code>bash    pip install -r requirements.txt</code></p> </li> </ol>"},{"location":"#executando-o-projeto","title":"Executando o Projeto","text":"<ol> <li> <p>Navegue at\u00e9 o diret\u00f3rio do projeto:    <code>bash    cd 2Do</code></p> </li> <li> <p>Execute o arquivo principal:    <code>bash    python main.py</code></p> </li> </ol>"},{"location":"#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Para come\u00e7ar a desenvolver com o 2Do, recomenda-se seguir esta documenta\u00e7\u00e3o na ordem:</p> <ol> <li>Configura\u00e7\u00e3o e Setup: Como configurar o ambiente de desenvolvimento.</li> <li>Estrutura Geral do Projeto: Entenda a organiza\u00e7\u00e3o dos arquivos e diret\u00f3rios.</li> <li>Sistema de Gerenciamento de Recursos: Aprenda a carregar e gerenciar assets.</li> <li>Entidades e Objetos do Jogo: Como criar e manipular personagens, itens e plataformas.</li> </ol>"},{"location":"#contribuicoes","title":"Contribui\u00e7\u00f5es","text":"<p>Contribui\u00e7\u00f5es s\u00e3o bem-vindas! Por favor, sinta-se \u00e0 vontade para:</p> <ul> <li>Abrir uma issue para reportar bugs.</li> <li>Propor novas funcionalidades.</li> <li>Enviar pull requests.</li> <li>Melhorar a documenta\u00e7\u00e3o.</li> </ul>"},{"location":"#contato","title":"Contato","text":"<p>Lucas Lattari \ud83d\udce7 Email: lucas.lattari@ifsudestemg.edu.br \ud83d\udc31 GitHub: @lucaslattari</p>"},{"location":"#agradecimentos","title":"Agradecimentos","text":"<p>Agradecimentos especiais a todos que contribu\u00edram com o projeto, seja atrav\u00e9s de c\u00f3digo, sugest\u00f5es ou reportando problemas. Um agradecimento especial ao time de desenvolvimento do Pygame e PyTMX por fornecerem ferramentas que tornaram este projeto poss\u00edvel.</p>"},{"location":"assets/","title":"Sistema de Gerenciamento de Recursos","text":"<p>Este documento explica como o 2Do gerencia recursos gr\u00e1ficos (sprites, tiles) e outros assets necess\u00e1rios para o funcionamento do jogo.</p>"},{"location":"assets/#visao-geral","title":"Vis\u00e3o Geral","text":"<p>O sistema de gerenciamento de recursos do 2Do \u00e9 centralizado no arquivo <code>asset_manager.py</code>, que cont\u00e9m a classe <code>AssetManager</code>. Esta classe \u00e9 respons\u00e1vel por:</p> <ol> <li>Carregar tiles e sprites de arquivos de mapa (formato TMX)</li> <li>Organizar os recursos por tipo (Player, Item, Platform, etc.)</li> <li>Extrair propriedades importantes (colis\u00e3o, anima\u00e7\u00e3o)</li> <li>Fornecer acesso f\u00e1cil aos recursos para outras partes do motor</li> </ol> <p>O 2Do utiliza a biblioteca PyTMX para carregar mapas criados com o Tiled Map Editor, o que permite aos desenvolvedores criar n\u00edveis visualmente e definir propriedades personalizadas para cada elemento do jogo.</p>"},{"location":"assets/#a-classe-assetmanager","title":"A Classe AssetManager","text":"<pre><code>class AssetManager:\n    def __init__(self, level, tile_types=None):\n        if tile_types is None:\n            tile_types = [\"Player\", \"Item\", \"Platform\"]\n        self.tile_types = tile_types\n        self.tiles = self.load_tiles(level)\n        self.tile_width = level.tilewidth\n        self.tile_height = level.tileheight\n</code></pre> <p>O construtor da classe aceita dois par\u00e2metros: - <code>level</code>: O objeto de n\u00edvel carregado pelo PyTMX (cont\u00e9m todas as informa\u00e7\u00f5es do mapa) - <code>tile_types</code>: Uma lista opcional de tipos de tiles a serem carregados (padr\u00e3o: Player, Item, Platform)</p>"},{"location":"assets/#processo-de-carregamento-de-recursos","title":"Processo de Carregamento de Recursos","text":""},{"location":"assets/#inicializacao","title":"Inicializa\u00e7\u00e3o","text":"<p>Quando um n\u00edvel \u00e9 carregado na classe <code>Game</code> atrav\u00e9s do m\u00e9todo <code>load_level()</code>, o seguinte processo ocorre:</p> <ol> <li>O arquivo TMX \u00e9 carregado usando <code>pytmx.load_pygame()</code></li> <li>Uma inst\u00e2ncia de <code>AssetManager</code> \u00e9 criada, recebendo o n\u00edvel carregado</li> <li>O <code>AssetManager</code> extrai todos os recursos e propriedades do arquivo TMX</li> <li>Os recursos s\u00e3o agrupados por tipo e disponibilizados para as entidades do jogo</li> </ol> <pre><code># Trecho de game.py\ndef load_level(self, level_filename):\n    try:\n        self.tiled_level = pytmx.load_pygame(level_filename)\n        self.load_assets()\n        # ...\n    except Exception as e:\n        print(f\"Erro ao carregar o n\u00edvel: {e}\")\n\ndef load_assets(self):\n    self.asset_manager = AssetManager(self.tiled_level)\n\n    self.player = Player(self.asset_manager.get_asset(\"Player\"))\n    self.item = Item(self.asset_manager.get_asset(\"Item\"))\n    self.platform = Platform(self.asset_manager.get_asset(\"Platform\"))\n</code></pre>"},{"location":"assets/#o-metodo-load_tiles","title":"O M\u00e9todo load_tiles","text":"<p>O m\u00e9todo <code>load_tiles</code> \u00e9 o cora\u00e7\u00e3o do sistema de carregamento de recursos:</p> <pre><code>def load_tiles(self, level):\n    tiles = {tile_type: [] for tile_type in self.tile_types}\n    gid_to_position = {}\n\n    # Reunir posi\u00e7\u00f5es dos GIDs\n    for layer in level.layers:\n        for x, y, gid in layer:\n            gid_to_position.setdefault(gid, []).append((x, y))\n\n    # Populando os tiles\n    for tileset in level.tilesets:\n        for gid in range(tileset.firstgid, tileset.firstgid + tileset.tilecount):\n            tile = level.get_tile_properties_by_gid(gid)\n            if not tile:\n                continue\n\n            tile[\"gid\"] = gid\n\n            # Verificar as propriedades especiais\n            tile[\"collidable_horizontal\"] = tile.get(\"collidable_horizontal\", False)\n            tile[\"collidable_vertical\"] = tile.get(\"collidable_vertical\", False)\n            tile[\"can_descend\"] = tile.get(\"can_descend\", False)\n\n            self.update_tiles(tile, tiles, gid_to_position.get(gid), level)\n\n    return tiles\n</code></pre> <p>Vamos analisar como este m\u00e9todo funciona:</p> <ol> <li>Prepara\u00e7\u00e3o das estruturas de dados:</li> <li>Cria um dicion\u00e1rio <code>tiles</code> para armazenar tiles organizados por tipo. Tiles podem ser de plataforma (por exemplo, um bloco de terra ou pedra onde o jogador caminha), de jogador (posi\u00e7\u00e3o do personagem principal) e de item (pode ser uma moeda, power-up ou chave).</li> <li>Cria um dicion\u00e1rio <code>gid_to_position</code> para mapear identificadores globais (GIDs) para suas posi\u00e7\u00f5es no mapa. O GID significa \"Global Identifier\", ou seja, um n\u00famero de s\u00e9rie \u00fanico para cada tipo de tile do jogo. </li> </ol> <p>Este dicion\u00e1rio \u00e9 como um mapa que diz: \"Este tipo de bloco (GID) aparece nestas coordenadas do mapa\". Por exemplo:</p> <ul> <li>O bloco de terra (GID 101) aparece nas posi\u00e7\u00f5es (5,10), (6,10) e (7,10) - formando uma plataforma horizontal</li> <li>A moeda dourada (GID 201) aparece na posi\u00e7\u00e3o (5,5) - flutuando acima da plataforma</li> <li>O personagem (GID 301) aparece na posi\u00e7\u00e3o (7,3) - posicionado para pular na plataforma</li> </ul> <p>Este mapeamento permite que o jogo saiba onde colocar cada elemento visual na tela.</p> <ol> <li>Mapeamento de posi\u00e7\u00f5es:</li> <li>Percorre todas as camadas do mapa</li> <li> <p>Para cada tile encontrado, registra sua posi\u00e7\u00e3o (x, y) no dicion\u00e1rio <code>gid_to_position</code></p> </li> <li> <p>Processamento de tilesets:</p> </li> <li>Percorre todos os tilesets carregados</li> <li>Para cada GID v\u00e1lido, obt\u00e9m as propriedades associadas</li> <li>Adiciona o GID \u00e0s propriedades e configura flags de colis\u00e3o (indicando quais tiles podem ser atravessados ou n\u00e3o pelo jogador)</li> <li>Chama <code>update_tiles</code> para processar os tiles e organiz\u00e1-los por tipo</li> </ol>"},{"location":"assets/#o-metodo-update_tiles","title":"O M\u00e9todo update_tiles","text":"<p>Este m\u00e9todo categoriza os tiles com base em seu tipo e prepara-os para uso no jogo:</p> <pre><code>def update_tiles(self, tile, tiles, gid_to_position, level):\n    tile_type = tile.get(\"type\")\n    if tile_type and any(tile_type.startswith(term) for term in self.tile_types):\n        tile[\"sprites\"] = self.load_sprites(level, tile)\n\n        if gid_to_position:\n            tile[\"position\"] = gid_to_position\n\n        if \"_\" in tile_type:\n            tile_type = tile_type.split(\"_\")[0]\n\n        if \"position\" in tile:\n            tiles[tile_type].append(tile)\n</code></pre> <p>Este m\u00e9todo: 1. Verifica se o tile possui um tipo definido que corresponde a um dos tipos esperados 2. Carrega os sprites associados ao tile atrav\u00e9s do m\u00e9todo <code>load_sprites</code> 3. Adiciona informa\u00e7\u00f5es de posi\u00e7\u00e3o ao tile 4. Processa o tipo do tile (removendo qualquer sufixo ap\u00f3s o underscore) 5. Adiciona o tile ao dicion\u00e1rio de tiles do tipo apropriado</p>"},{"location":"assets/#o-metodo-load_sprites","title":"O M\u00e9todo load_sprites","text":"<p>O m\u00e9todo <code>load_sprites</code> \u00e9 respons\u00e1vel por carregar as imagens dos tiles, incluindo suporte para anima\u00e7\u00f5es:</p> <pre><code>def load_sprites(self, level, tile):\n    sprites = []\n    frames = tile.get(\"frames\", [])\n\n    if not frames:\n        sprite = level.get_tile_image_by_gid(tile[\"gid\"])\n        if sprite:\n            sprites.append(sprite)\n    else:\n        for frame in frames:\n            sprite = level.get_tile_image_by_gid(frame.gid)\n            if sprite:\n                sprites.append(sprite)\n    return sprites\n</code></pre> <p>Este m\u00e9todo: 1. Verifica se o tile possui frames de anima\u00e7\u00e3o definidos 2. Se n\u00e3o houver frames, carrega a imagem est\u00e1tica do tile 3. Se houver frames, carrega cada frame como um sprite separado 4. Retorna uma lista de sprites que pode conter uma \u00fanica imagem (tile est\u00e1tico) ou m\u00faltiplas imagens (anima\u00e7\u00e3o)</p>"},{"location":"assets/#acessando-os-recursos","title":"Acessando os Recursos","text":"<p>Ap\u00f3s o carregamento, os recursos podem ser acessados atrav\u00e9s do m\u00e9todo <code>get_asset</code>:</p> <pre><code>def get_asset(self, asset_type):\n    return self.tiles.get(asset_type, [])\n</code></pre> <p>Este m\u00e9todo retorna todos os tiles de um determinado tipo (por exemplo, \"Player\", \"Item\", \"Platform\"). Esses tiles s\u00e3o ent\u00e3o passados para as classes correspondentes durante a inicializa\u00e7\u00e3o:</p> <pre><code># Em game.py\nself.player = Player(self.asset_manager.get_asset(\"Player\"))\nself.item = Item(self.asset_manager.get_asset(\"Item\"))\nself.platform = Platform(self.asset_manager.get_asset(\"Platform\"))\n</code></pre>"},{"location":"assets/#propriedades-especiais-de-tiles","title":"Propriedades Especiais de Tiles","text":"<p>O AssetManager reconhece e processa propriedades especiais definidas no Tiled Map Editor:</p> <ul> <li><code>collidable_horizontal</code>: Indica se o tile causa colis\u00e3o horizontal (impede movimento lateral)</li> <li><code>collidable_vertical</code>: Indica se o tile causa colis\u00e3o vertical (impede movimento para cima/baixo)</li> <li><code>can_descend</code>: Indica se o jogador pode descer atrav\u00e9s da plataforma (pressionando para baixo)</li> </ul> <p>Estas propriedades devem ser definidas no Tiled Map Editor como propriedades personalizadas dos tiles.</p>"},{"location":"assets/#estrutura-de-dados-de-tiles","title":"Estrutura de Dados de Tiles","text":"<p>Cada tile processado pelo AssetManager possui a seguinte estrutura:</p> <pre><code>{\n    \"gid\": 123,                        # Identificador global do tile\n    \"width\": 16,                       # Largura do tile em pixels\n    \"height\": 16,                      # Altura do tile em pixels\n    \"position\": [(x1, y1), (x2, y2)],  # Lista de posi\u00e7\u00f5es no mapa\n    \"sprites\": [sprite1, sprite2],     # Lista de sprites (um ou mais para anima\u00e7\u00e3o)\n    \"collidable_horizontal\": True,     # Flag de colis\u00e3o horizontal\n    \"collidable_vertical\": True,       # Flag de colis\u00e3o vertical\n    \"can_descend\": False,              # Flag para permitir descida\n    \"type\": \"Platform\"                 # Tipo do tile\n}\n</code></pre>"},{"location":"assets/#dicas-para-criar-mapas-compativeis","title":"Dicas para Criar Mapas Compat\u00edveis","text":"<p>Para criar mapas compat\u00edveis com o sistema de assets do 2Do:</p> <ol> <li>Nomeie corretamente os tipos de tiles:</li> <li>Para o jogador: \"Player_idle\", \"Player_run\", \"Player_jump\"</li> <li>Para plataformas: \"Platform\"</li> <li> <p>Para itens: \"Item\"</p> </li> <li> <p>Configure propriedades de colis\u00e3o:</p> </li> <li>Adicione propriedades booleanas <code>collidable_horizontal</code> e <code>collidable_vertical</code> \u00e0s plataformas</li> <li> <p>Para plataformas que permitem descida, defina <code>can_descend</code> como <code>true</code></p> </li> <li> <p>Configure anima\u00e7\u00f5es:</p> </li> <li>Para tiles animados, configure os frames no Tiled Map Editor</li> <li> <p>O AssetManager carregar\u00e1 automaticamente todos os frames</p> </li> <li> <p>Organize camadas no Tiled:</p> </li> <li>Separe diferentes tipos de entidades em camadas distintas para melhor organiza\u00e7\u00e3o</li> </ol>"},{"location":"assets/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Agora que voc\u00ea entende como o 2Do gerencia recursos, pode explorar:</p> <ul> <li>Entidades e Objetos do Jogo - Como os recursos carregados s\u00e3o utilizados pelas entidades</li> <li>Plano de Fundo e Interface - Como o sistema de fundo usa recursos de imagem</li> </ul>"},{"location":"configuracao/","title":"Configura\u00e7\u00e3o e Setup do 2Do","text":"<p>Este guia apresenta como preparar o ambiente de desenvolvimento do 2Do e entender as configura\u00e7\u00f5es b\u00e1sicas para executar o projeto. Lembre-se de que o 2Do ainda est\u00e1 em desenvolvimento, ent\u00e3o alguns recursos podem mudar ao longo do tempo.</p>"},{"location":"configuracao/#requisitos-de-sistema","title":"Requisitos de Sistema","text":"<p>Para executar o 2Do, voc\u00ea precisar\u00e1 de:</p> <ul> <li>Python 3.8 ou superior - Download Python</li> <li>Pygame 2.3.0 - Instalado automaticamente com as depend\u00eancias</li> <li>PyTMX 3.31 - Instalado automaticamente com as depend\u00eancias</li> </ul>"},{"location":"configuracao/#instalacao","title":"Instala\u00e7\u00e3o","text":""},{"location":"configuracao/#1-obtendo-o-codigo","title":"1. Obtendo o C\u00f3digo","text":"<p>Clone o reposit\u00f3rio ou baixe os arquivos do projeto para o seu computador.</p> <pre><code>git clone https://github.com/seu-usuario/2do.git\ncd 2do\n</code></pre>"},{"location":"configuracao/#2-configurando-o-ambiente-virtual-recomendado","title":"2. Configurando o Ambiente Virtual (Recomendado)","text":"<p>\u00c9 recomend\u00e1vel usar um ambiente virtual para manter as depend\u00eancias isoladas:</p> <pre><code>python -m venv venv\n</code></pre> <p>Ativando o ambiente virtual:</p> <p>Windows:</p> <pre><code>venv\\Scripts\\activate\n</code></pre> <p>macOS/Linux:</p> <pre><code>source venv/bin/activate\n</code></pre>"},{"location":"configuracao/#3-instalando-dependencias","title":"3. Instalando Depend\u00eancias","text":"<p>Todas as depend\u00eancias necess\u00e1rias est\u00e3o listadas no arquivo <code>requirements.txt</code>:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"configuracao/#arquivo-de-configuracao-configini","title":"Arquivo de Configura\u00e7\u00e3o (config.ini)","text":"<p>O 2Do utiliza um arquivo de configura\u00e7\u00e3o no formato INI para personalizar diversos aspectos do jogo. Este arquivo \u00e9 lido pelo <code>configparser</code> do Python e aplicado ao iniciar o jogo.</p>"},{"location":"configuracao/#estrutura-do-arquivo","title":"Estrutura do Arquivo","text":"<p>O arquivo <code>config.ini</code> padr\u00e3o cont\u00e9m as seguintes se\u00e7\u00f5es:</p> <pre><code>[graphics]\nresolution = 1280x720\nfullscreen = no\n\n[audio]\nvolume = 80\n\n[background]\nimage = graphics/Background/Brown.png\nx_block_bounds = 12,62\ny_block_bounds = 10,37\nscroll_speed = 0.6\n\n[controls]\nup = K_UP\ndown = K_DOWN\nleft = K_LEFT\nright = K_RIGHT\njump = K_SPACE\n</code></pre>"},{"location":"configuracao/#configuracoes-detalhadas","title":"Configura\u00e7\u00f5es Detalhadas","text":""},{"location":"configuracao/#graficos","title":"Gr\u00e1ficos","text":"<p>Na se\u00e7\u00e3o <code>[graphics]</code>, voc\u00ea pode configurar:</p> <ul> <li>resolution: Define a resolu\u00e7\u00e3o da janela do jogo no formato <code>LARGURAxALTURA</code></li> <li>fullscreen: Ativa (<code>yes</code>) ou desativa (<code>no</code>) o modo de tela cheia</li> </ul> <p>O c\u00f3digo em <code>game.py</code> aplica essas configura\u00e7\u00f5es durante a inicializa\u00e7\u00e3o:</p> <pre><code>resolution_str = self.config_parser.get(\"graphics\", \"resolution\", fallback=\"1280x720\")\nself.width, self.height = map(int, resolution_str.split(\"x\"))\n</code></pre>"},{"location":"configuracao/#audio","title":"\u00c1udio","text":"<p>Na se\u00e7\u00e3o <code>[audio]</code>, voc\u00ea pode configurar:</p> <ul> <li>volume: Define o volume global do jogo (0-100)</li> </ul>"},{"location":"configuracao/#plano-de-fundo","title":"Plano de Fundo","text":"<p>Na se\u00e7\u00e3o <code>[background]</code>, voc\u00ea pode personalizar o fundo do jogo:</p> <ul> <li>image: Caminho para a imagem de fundo (relativo \u00e0 raiz do projeto)</li> <li>x_block_bounds: Limites horizontais para repeti\u00e7\u00e3o do plano de fundo (formato <code>min,max</code>)</li> <li>y_block_bounds: Limites verticais para repeti\u00e7\u00e3o do plano de fundo (formato <code>min,max</code>)</li> <li>scroll_speed: Velocidade de rolagem do plano de fundo (valores maiores = movimento mais r\u00e1pido)</li> </ul>"},{"location":"configuracao/#entendendo-os-limites-de-blocos","title":"Entendendo os Limites de Blocos","text":"<p>No 2Do, o plano de fundo \u00e9 constru\u00eddo repetindo (ou \"tilando\") uma imagem base. Os par\u00e2metros <code>x_block_bounds</code> e <code>y_block_bounds</code> definem quantos blocos ser\u00e3o usados para criar esse fundo:</p> <ul> <li>Se um bloco tem 16x16 pixels e voc\u00ea define <code>x_block_bounds = 12,62</code>, o plano de fundo ter\u00e1 50 blocos de largura (62-12)</li> <li>Com <code>y_block_bounds = 10,37</code>, o plano de fundo ter\u00e1 27 blocos de altura (37-10)</li> </ul> <p>Esses valores s\u00e3o utilizados na classe <code>Background</code> para criar um fundo cont\u00ednuo que cobre toda a \u00e1rea vis\u00edvel do jogo:</p> <pre><code>bg_width = (self.x_block_bounds[1] - self.x_block_bounds[0]) * self.tile_bg.get_width()\nbg_height = (self.y_block_bounds[1] - self.y_block_bounds[0]) * self.tile_bg.get_height()\n</code></pre>"},{"location":"configuracao/#controles","title":"Controles","text":"<p>Na se\u00e7\u00e3o <code>[controls]</code>, voc\u00ea pode definir as teclas utilizadas para cada a\u00e7\u00e3o no jogo:</p> <ul> <li>up: Tecla para mover para cima/pular</li> <li>down: Tecla para mover para baixo/agachar</li> <li>left: Tecla para mover para a esquerda</li> <li>right: Tecla para mover para a direita</li> <li>jump: Tecla para pular</li> </ul> <p>Os valores correspondem \u00e0s constantes de tecla do Pygame (ex: <code>K_SPACE</code>, <code>K_UP</code>, etc.). </p> <p>O jogo tamb\u00e9m tem teclas globais predefinidas: - ESC: Sai do jogo - F11: Alterna entre tela cheia e modo janela</p>"},{"location":"configuracao/#dicas-para-configuracao","title":"Dicas para Configura\u00e7\u00e3o","text":""},{"location":"configuracao/#otimizando-o-desempenho","title":"Otimizando o Desempenho","text":"<ul> <li>Para melhor desempenho em dispositivos com recursos limitados, reduza a resolu\u00e7\u00e3o (ex: <code>800x600</code>)</li> <li>Mantenha a velocidade de rolagem do fundo (<code>scroll_speed</code>) entre 0.3 e 0.8 para um efeito visualmente agrad\u00e1vel</li> </ul>"},{"location":"configuracao/#personalizando-visualmente","title":"Personalizando Visualmente","text":"<ul> <li>Voc\u00ea pode substituir a imagem de fundo por qualquer arquivo PNG compat\u00edvel</li> <li>Ajuste os limites de blocos para garantir que a \u00e1rea do jogo seja totalmente coberta</li> </ul>"},{"location":"configuracao/#configuracao-de-controles","title":"Configura\u00e7\u00e3o de Controles","text":"<ul> <li>Adicione teclas alternativas duplicando entradas com o mesmo valor de a\u00e7\u00e3o:</li> </ul> <pre><code>[controls]\nup = K_UP\nup_alt = K_w\ndown = K_DOWN\ndown_alt = K_s\n# etc.\n</code></pre>"},{"location":"configuracao/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Ap\u00f3s configurar o ambiente e personalizar o arquivo <code>config.ini</code>, voc\u00ea pode avan\u00e7ar para a se\u00e7\u00e3o Estrutura Geral do Projeto para entender como o 2Do \u00e9 organizado, ou pular para Arquivo Principal e Execu\u00e7\u00e3o para instru\u00e7\u00f5es sobre como executar seu primeiro jogo com o 2Do.</p>"},{"location":"controle/","title":"Sistema de Entrada e Controle","text":"<p>Este documento explica como o 2Do gerencia a entrada do usu\u00e1rio, processa eventos de teclado e mapeia teclas para a\u00e7\u00f5es no jogo. O sistema de controle \u00e9 centralizado na classe <code>InputHandler</code>, que fornece uma camada de abstra\u00e7\u00e3o entre o hardware (teclado) e a l\u00f3gica do jogo.</p>"},{"location":"controle/#visao-geral-do-sistema-de-controle","title":"Vis\u00e3o Geral do Sistema de Controle","text":"<p>O 2Do implementa um sistema de controle baseado em mapeamento de teclas para a\u00e7\u00f5es, permitindo:</p> <ol> <li>Configura\u00e7\u00e3o flex\u00edvel de controles atrav\u00e9s do arquivo <code>config.ini</code></li> <li>Processamento centralizado de eventos de teclado</li> <li>Verifica\u00e7\u00e3o simplificada do estado de teclas durante a atualiza\u00e7\u00e3o do jogo</li> <li>Suporte a teclas globais como ESC (sair) e F11 (alternar tela cheia)</li> </ol> <p>A arquitetura do sistema separa claramente a entrada de dados da l\u00f3gica de jogo, facilitando personaliza\u00e7\u00f5es e extens\u00f5es.</p>"},{"location":"controle/#a-classe-inputhandler","title":"A Classe InputHandler","text":"<p>O arquivo <code>input_handler.py</code> cont\u00e9m a classe <code>InputHandler</code>, respons\u00e1vel por todo o processamento de entrada do usu\u00e1rio:</p> <pre><code>class InputHandler:\n    def __init__(self, config_parser):\n        self.quit_game = False\n        self.fullscreen_toggled = False\n\n        # Carregar as teclas de controle do arquivo de configura\u00e7\u00e3o\n        self.key_map = {}\n        self.key_state = {}\n        if config_parser.has_section(\"controls\"):\n            for action, key_name in config_parser.items(\"controls\"):\n                try:\n                    key_constant = getattr(pygame, key_name)\n                    self.key_map[key_constant] = action\n                    self.key_state[action] = False\n                except AttributeError:\n                    print(f\"Tecla inv\u00e1lida no arquivo de configura\u00e7\u00e3o: {key_name}\")\n        else:\n            # Valores padr\u00e3o caso a se\u00e7\u00e3o 'controls' n\u00e3o exista\n            self.key_map = {\n                pygame.K_UP: \"up\",\n                pygame.K_DOWN: \"down\",\n                pygame.K_LEFT: \"left\",\n                pygame.K_RIGHT: \"right\",\n                pygame.K_SPACE: \"jump\",\n                pygame.K_a: \"left\",\n                pygame.K_d: \"right\",\n                pygame.K_w: \"up\",\n                pygame.K_s: \"down\",\n            }\n            self.key_state = {action: False for action in self.key_map.values()}\n</code></pre> <p>O construtor da classe realiza as seguintes tarefas: 1. Inicializa flags de controle (<code>quit_game</code>, <code>fullscreen_toggled</code>) 2. Tenta carregar mapeamentos de teclas do arquivo de configura\u00e7\u00e3o 3. Se a configura\u00e7\u00e3o n\u00e3o for encontrada, configura mapeamentos padr\u00e3o que incluem tanto as setas direcionais quanto WASD 4. Inicializa o estado de cada a\u00e7\u00e3o (pressionada ou n\u00e3o)</p>"},{"location":"controle/#configuracao-de-controles","title":"Configura\u00e7\u00e3o de Controles","text":"<p>O 2Do permite dois m\u00e9todos para configurar os controles do jogo:</p>"},{"location":"controle/#1-atraves-do-arquivo-configini","title":"1. Atrav\u00e9s do Arquivo config.ini","text":"<p>Voc\u00ea pode adicionar uma se\u00e7\u00e3o <code>[controls]</code> ao arquivo <code>config.ini</code> para personalizar as teclas:</p> <pre><code>[controls]\nup = K_UP\ndown = K_DOWN\nleft = K_LEFT\nright = K_RIGHT\njump = K_SPACE\n</code></pre> <p>Cada linha mapeia uma a\u00e7\u00e3o (como \"up\" ou \"jump\") para uma constante de tecla do Pygame (como \"K_UP\" ou \"K_SPACE\").</p> <p>Importante: Se voc\u00ea definir controles personalizados no <code>config.ini</code>, apenas os controles especificados estar\u00e3o dispon\u00edveis. O suporte autom\u00e1tico a WASD n\u00e3o \u00e9 inclu\u00eddo neste caso, a menos que voc\u00ea adicione explicitamente essas teclas \u00e0 configura\u00e7\u00e3o.</p>"},{"location":"controle/#2-controles-padrao","title":"2. Controles Padr\u00e3o","text":"<p>Se o arquivo <code>config.ini</code> n\u00e3o contiver uma se\u00e7\u00e3o <code>[controls]</code>, o sistema ativa automaticamente um conjunto padr\u00e3o de mapeamentos:</p> <ul> <li>Setas direcionais: Movimenta\u00e7\u00e3o (cima, baixo, esquerda, direita)</li> <li>WASD: Controles alternativos para movimenta\u00e7\u00e3o (W=cima, A=esquerda, S=baixo, D=direita)</li> <li>Barra de espa\u00e7o: Pular</li> </ul> <p>Esta configura\u00e7\u00e3o padr\u00e3o \u00e9 amig\u00e1vel para jogadores destros e canhotos, oferecendo duas op\u00e7\u00f5es comuns para controle de movimento sem necessidade de configura\u00e7\u00e3o adicional.</p>"},{"location":"controle/#processamento-de-eventos","title":"Processamento de Eventos","text":"<p>O m\u00e9todo <code>process_events</code> \u00e9 o cora\u00e7\u00e3o do sistema de controle, processando a fila de eventos do Pygame a cada quadro:</p> <pre><code>def process_events(self):\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            self.quit_game = True\n\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_ESCAPE:\n                self.quit_game = True\n            elif event.key == pygame.K_F11:\n                self.fullscreen_toggled = True\n\n            key_action = self.key_map.get(event.key)\n            if key_action:\n                self.key_state[key_action] = True\n\n        elif event.type == pygame.KEYUP:\n            key_action = self.key_map.get(event.key)\n            if key_action:\n                self.key_state[key_action] = False\n</code></pre> <p>Este m\u00e9todo: 1. Itera por todos os eventos pendentes no Pygame 2. Processa eventos de sa\u00edda (fechar janela) 3. Verifica teclas especiais (ESC para sair, F11 para tela cheia) 4. Atualiza o estado de a\u00e7\u00f5es mapeadas conforme teclas s\u00e3o pressionadas ou liberadas</p>"},{"location":"controle/#verificacao-de-estado-de-teclas","title":"Verifica\u00e7\u00e3o de Estado de Teclas","text":"<p>A classe fornece um m\u00e9todo simples para verificar se uma a\u00e7\u00e3o est\u00e1 ativa:</p> <pre><code>def is_pressed(self, action):\n    return self.key_state.get(action, False)\n</code></pre> <p>Este m\u00e9todo \u00e9 usado em todo o c\u00f3digo do jogo para verificar entradas do usu\u00e1rio, como no trecho de <code>player.py</code>:</p> <pre><code># Exemplo de uso em Player.update_state_and_velocity\nif input_handler.is_pressed(\"left\"):\n    self.face_direction = \"left\"\n    if self.on_ground:\n        self.state = \"run\"\n    self.velocity = max(-self.max_velocity, self.velocity - self.acceleration)\n</code></pre> <p>A abordagem baseada em a\u00e7\u00f5es (em vez de teclas espec\u00edficas) torna o c\u00f3digo mais limpo e facilita a personaliza\u00e7\u00e3o dos controles sem modificar a l\u00f3gica do jogo.</p>"},{"location":"controle/#controle-de-modo-de-tela","title":"Controle de Modo de Tela","text":"<p>O <code>InputHandler</code> tamb\u00e9m gerencia a altern\u00e2ncia entre tela cheia e modo janela:</p> <pre><code>def reset_toggle_fullscreen(self):\n    self.fullscreen_toggled = False\n</code></pre> <p>Quando a tecla F11 \u00e9 pressionada, a flag <code>fullscreen_toggled</code> \u00e9 definida. A classe <code>Game</code> verifica esta flag durante sua atualiza\u00e7\u00e3o:</p> <pre><code># Em Game.update\nif input_handler.fullscreen_toggled:\n    self.toggle_fullscreen()\n    input_handler.reset_toggle_fullscreen()\n</code></pre> <p>Este padr\u00e3o evita que a mesma tecla F11 alterne o modo repetidamente em um \u00fanico pressionamento.</p>"},{"location":"controle/#acoes-suportadas","title":"A\u00e7\u00f5es Suportadas","text":"<p>O 2Do atualmente suporta as seguintes a\u00e7\u00f5es de jogo:</p> A\u00e7\u00e3o Descri\u00e7\u00e3o Teclas Padr\u00e3o (sem configura\u00e7\u00e3o personalizada) <code>up</code> Mover para cima / Pular Seta para cima, W <code>down</code> Mover para baixo / Descer por plataformas Seta para baixo, S <code>left</code> Mover para a esquerda Seta para a esquerda, A <code>right</code> Mover para a direita Seta para a direita, D <code>jump</code> Pular (alias para <code>up</code> em alguns contextos) Barra de espa\u00e7o <p>Al\u00e9m disso, as seguintes teclas globais s\u00e3o sempre processadas independentemente da configura\u00e7\u00e3o:</p> Tecla Fun\u00e7\u00e3o <code>ESC</code> Sair do jogo <code>F11</code> Alternar modo tela cheia"},{"location":"controle/#expandindo-o-sistema-de-controle","title":"Expandindo o Sistema de Controle","text":"<p>O sistema de controle foi projetado para ser facilmente extens\u00edvel. Aqui est\u00e3o algumas maneiras de expandir sua funcionalidade:</p>"},{"location":"controle/#1-adicionar-novas-acoes","title":"1. Adicionar Novas A\u00e7\u00f5es","text":"<p>Para adicionar uma nova a\u00e7\u00e3o (como \"atacar\" ou \"usar item\"):</p> <ol> <li> <p>Adicione a nova a\u00e7\u00e3o ao arquivo <code>config.ini</code>:    <code>ini    [controls]    up = K_UP    down = K_DOWN    left = K_LEFT    right = K_RIGHT    jump = K_SPACE    attack = K_LCTRL</code></p> </li> <li> <p>Verifique a nova a\u00e7\u00e3o em seu c\u00f3digo:    <code>python    if input_handler.is_pressed(\"attack\"):        player.attack()</code></p> </li> </ol>"},{"location":"controle/#2-suporte-a-controles-alternativos","title":"2. Suporte a Controles Alternativos","text":"<p>Voc\u00ea pode adicionar controles alternativos usando nomes de a\u00e7\u00e3o com sufixos diferentes:</p> <pre><code>[controls]\nup = K_UP\nup_alt = K_w\ndown = K_DOWN\ndown_alt = K_s\nleft = K_LEFT\nleft_alt = K_a\nright = K_RIGHT\nright_alt = K_d\njump = K_SPACE\n</code></pre> <p>Em seguida, verifique as a\u00e7\u00f5es no c\u00f3digo como faria normalmente:</p> <pre><code>if input_handler.is_pressed(\"up\"):\n    # L\u00f3gica para movimento para cima (acionado por seta para cima OU tecla W)\n</code></pre> <p>O sistema de mapeamento de teclas garante que quaisquer teclas mapeadas para a mesma a\u00e7\u00e3o acionar\u00e3o o mesmo comportamento.</p>"},{"location":"controle/#3-suporte-a-gamepad","title":"3. Suporte a Gamepad","text":"<p>Uma extens\u00e3o natural seria adicionar suporte a gamepad, estendendo o <code>InputHandler</code> para processar eventos de joystick do Pygame.</p>"},{"location":"controle/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Agora que voc\u00ea compreende o sistema de controle do 2Do, pode explorar:</p> <ul> <li>L\u00f3gica de Jogo e Jogador - Como o jogador responde \u00e0s entradas do usu\u00e1rio</li> <li>Utilit\u00e1rios e Configura\u00e7\u00e3o - Mais op\u00e7\u00f5es de configura\u00e7\u00e3o dispon\u00edveis</li> <li>Plano de Fundo e Interface - Como a interface do jogo \u00e9 renderizada</li> </ul>"},{"location":"entidades/","title":"Entidades e Objetos do Jogo","text":"<p>Este documento explora o sistema de entidades do 2Do, explicando como objetos do jogo s\u00e3o representados, atualizados e renderizados. O sistema de entidades fornece a base para todos os elementos interativos do jogo, desde o jogador at\u00e9 plataformas e itens.</p>"},{"location":"entidades/#visao-geral-do-sistema-de-entidades","title":"Vis\u00e3o Geral do Sistema de Entidades","text":"<p>No 2Do, todas as entidades s\u00e3o constru\u00eddas a partir de um sistema de classes hier\u00e1rquico:</p> <ul> <li>A classe <code>Tile</code> representa a unidade b\u00e1sica visual (um ladrilho ou sprite)</li> <li>A classe <code>Entity</code> atua como base para todos os objetos interativos no jogo</li> <li>Classes espec\u00edficas como <code>Player</code>, <code>Platform</code> e <code>Item</code> estendem a classe <code>Entity</code> com comportamentos \u00fanicos</li> </ul> <p>Este design orientado a objetos permite reutiliza\u00e7\u00e3o de c\u00f3digo e extensibilidade, tornando f\u00e1cil adicionar novos tipos de entidades ao jogo.</p>"},{"location":"entidades/#a-classe-tile","title":"A Classe Tile","text":"<p>A classe <code>Tile</code> (definida em <code>entity.py</code>) representa um elemento visual fundamental do jogo. Um tile pode ser uma parte de uma plataforma, um item colet\u00e1vel, ou um quadro de anima\u00e7\u00e3o do personagem.</p>"},{"location":"entidades/#propriedades-principais","title":"Propriedades Principais","text":"<pre><code>class Tile:\n    def __init__(self, tile_data):\n        self.current_frame = 0\n        self.timer_next_frame = 0.0\n        self.id = tile_data.get(\"id\")\n        self.width = tile_data.get(\"width\")\n        self.height = tile_data.get(\"height\")\n        self.position = tile_data.get(\"position\", []).copy()\n        self.sprites = tile_data.get(\"sprites\")\n        self.collidable_horizontal = tile_data.get(\"collidable_horizontal\", False)\n        self.collidable_vertical = tile_data.get(\"collidable_vertical\", False)\n        self.can_descend = tile_data.get(\"can_descend\", False)\n</code></pre> <p>Cada tile possui:</p> <ul> <li>Informa\u00e7\u00f5es de tamanho (<code>width</code>, <code>height</code>): dimens\u00f5es do tile em pixels</li> <li>Posi\u00e7\u00e3o (<code>position</code>): lista de coordenadas onde este tile aparece no mapa, em unidades de tile (n\u00e3o pixels)</li> <li>Sprites (<code>sprites</code>): imagens que representam o tile (m\u00faltiplas para anima\u00e7\u00f5es)</li> <li>Propriedades de colis\u00e3o (<code>collidable_horizontal</code>, <code>collidable_vertical</code>): determinam como o tile interage com outras entidades</li> <li>Propriedade especial (<code>can_descend</code>): indica se o jogador pode descer por esta plataforma</li> </ul>"},{"location":"entidades/#animacao-de-tiles","title":"Anima\u00e7\u00e3o de Tiles","text":"<p>A classe <code>Tile</code> inclui suporte para anima\u00e7\u00e3o atrav\u00e9s de seus m\u00e9todos <code>update</code> e <code>render</code>:</p> <pre><code>def update(self, delta_time, frame_duration=0.1):\n    self.timer_next_frame += delta_time\n    if self.timer_next_frame &gt;= frame_duration:\n        self.current_frame = (self.current_frame + 1) % len(self.sprites)\n        self.timer_next_frame -= frame_duration\n</code></pre> <p>Este m\u00e9todo: 1. Acumula o tempo decorrido desde o \u00faltimo quadro 2. Quando o tempo acumulado excede a dura\u00e7\u00e3o do quadro, avan\u00e7a para o pr\u00f3ximo 3. Reinicia o temporizador para o pr\u00f3ximo ciclo de anima\u00e7\u00e3o</p> <p>A anima\u00e7\u00e3o funciona avan\u00e7ando ciclicamente pelos sprites dispon\u00edveis no array <code>self.sprites</code>.</p>"},{"location":"entidades/#renderizacao-de-tiles","title":"Renderiza\u00e7\u00e3o de Tiles","text":"<pre><code>def render(self, screen, block_size):\n    for pos in self.position:\n        screen.blit(\n            self.sprites[self.current_frame],\n            (\n                pos[0] * block_size[0],\n                pos[1] * block_size[1],\n            ),\n        )\n</code></pre> <p>O m\u00e9todo <code>render</code>: 1. Percorre todas as posi\u00e7\u00f5es onde este tile deve aparecer 2. Desenha o sprite atual (determinado por <code>current_frame</code>) em cada posi\u00e7\u00e3o 3. Converte coordenadas de tile para coordenadas de pixel multiplicando pela dimens\u00e3o do bloco</p>"},{"location":"entidades/#retangulos-de-colisao","title":"Ret\u00e2ngulos de Colis\u00e3o","text":"<pre><code>def get_rect(self, block_size):\n    rects = []\n    for pos in self.position:\n        rect = pygame.Rect(\n            pos[0] * block_size[0], pos[1] * block_size[1], self.width, self.height\n        )\n        rects.append(rect)\n    return rects\n</code></pre> <p>Este m\u00e9todo cria ret\u00e2ngulos de colis\u00e3o pygame para cada posi\u00e7\u00e3o do tile, convertendo coordenadas de tile para coordenadas de pixel.</p>"},{"location":"entidades/#a-classe-entity","title":"A Classe Entity","text":"<p>A classe <code>Entity</code> (tamb\u00e9m em <code>entity.py</code>) serve como base para todos os objetos interativos do jogo. Ela gerencia um conjunto de tiles e fornece m\u00e9todos comuns para atualiza\u00e7\u00e3o, renderiza\u00e7\u00e3o e detec\u00e7\u00e3o de colis\u00e3o.</p> <pre><code>class Entity:\n    def __init__(self, tile_data):\n        self.tiles = []\n        self.parse(tile_data)\n\n    def parse(self, tile_data):\n        for t in tile_data:\n            tile = Tile(t)\n            self.tiles.append(tile)\n</code></pre> <p>Uma <code>Entity</code> \u00e9 essencialmente uma cole\u00e7\u00e3o de <code>Tile</code>s que s\u00e3o tratados como um \u00fanico objeto l\u00f3gico. Por exemplo: - Um <code>Player</code> pode ter diferentes conjuntos de tiles para estados como \"idle\", \"running\" e \"jumping\" - Uma <code>Platform</code> pode consistir de m\u00faltiplos tiles conectados</p>"},{"location":"entidades/#metodos-principais","title":"M\u00e9todos Principais","text":"<pre><code>def render(self, screen, block_size):\n    for tile in self.tiles:\n        tile.render(screen, block_size)\n\ndef update(self, delta_time):\n    for tile in self.tiles:\n        tile.update(delta_time)\n\ndef check_collision(self, rect1, rect2):\n    return pygame.Rect(rect1).colliderect(pygame.Rect(rect2))\n</code></pre> <p>Estes m\u00e9todos: 1. <code>render</code>: Desenha todos os tiles da entidade na tela 2. <code>update</code>: Atualiza o estado de todos os tiles (anima\u00e7\u00e3o, etc.) 3. <code>check_collision</code>: Verifica se dois ret\u00e2ngulos est\u00e3o colidindo</p>"},{"location":"entidades/#entidades-especificas","title":"Entidades Espec\u00edficas","text":""},{"location":"entidades/#a-classe-platform","title":"A Classe Platform","text":"<p>Definida em <code>platformer.py</code>, a classe <code>Platform</code> representa superf\u00edcies onde o jogador pode andar, pular ou se mover:</p> <pre><code>from entity import Entity\n\nclass Platform(Entity):\n    def __init__(self, data):\n        super().__init__(data)\n</code></pre> <p>Embora simples em sua implementa\u00e7\u00e3o, as plataformas t\u00eam propriedades importantes que s\u00e3o definidas nos dados de seus tiles:</p> <ul> <li><code>collidable_horizontal</code>: Se verdadeiro, o jogador n\u00e3o pode passar horizontalmente atrav\u00e9s da plataforma</li> <li><code>collidable_vertical</code>: Se verdadeiro, o jogador n\u00e3o pode passar verticalmente atrav\u00e9s da plataforma</li> <li><code>can_descend</code>: Se verdadeiro, o jogador pode descer pela plataforma pressionando a tecla para baixo</li> </ul> <p>Estas propriedades permitem criar diversos tipos de plataformas: - Plataformas s\u00f3lidas: Bloqueiam movimento em todas as dire\u00e7\u00f5es (<code>collidable_horizontal</code> e <code>collidable_vertical</code> s\u00e3o <code>True</code>) - Plataformas de m\u00e3o \u00fanica: Permitem que o jogador pule atrav\u00e9s delas de baixo, mas fornecem suporte quando atingidas por cima (apenas <code>collidable_vertical</code> \u00e9 <code>True</code>) - Plataformas atravess\u00e1veis: Permitem que o jogador des\u00e7a atrav\u00e9s delas pressionando para baixo (<code>can_descend</code> \u00e9 <code>True</code>)</p>"},{"location":"entidades/#a-classe-item","title":"A Classe Item","text":"<p>Definida em <code>item.py</code>, a classe <code>Item</code> representa objetos colet\u00e1veis ou interativos no jogo:</p> <pre><code>from entity import Entity\n\nclass Item(Entity):\n    def __init__(self, data):\n        super().__init__(data)\n</code></pre> <p>A implementa\u00e7\u00e3o da classe <code>Item</code> est\u00e1 em desenvolvimento, servindo como base para expans\u00e3o futura. Poss\u00edveis extens\u00f5es incluem: - Adicionar l\u00f3gica para coletar itens - Implementar efeitos para diferentes tipos de itens - Criar anima\u00e7\u00f5es para itens</p>"},{"location":"entidades/#sistema-de-colisoes","title":"Sistema de Colis\u00f5es","text":"<p>Atualmente, a detec\u00e7\u00e3o de colis\u00e3o no 2Do \u00e9 implementada principalmente na classe <code>Player</code> (em <code>player.py</code>), utilizando o m\u00f3dulo <code>pygame.Rect</code>.</p>"},{"location":"entidades/#verificacao-basica-de-colisao","title":"Verifica\u00e7\u00e3o B\u00e1sica de Colis\u00e3o","text":"<pre><code>def check_collision(self, rect1, rect2):\n    return pygame.Rect(rect1).colliderect(pygame.Rect(rect2))\n</code></pre> <p>Este m\u00e9todo simples verifica se dois ret\u00e2ngulos se sobrep\u00f5em, sendo a base para todas as colis\u00f5es no jogo.</p>"},{"location":"entidades/#colisao-horizontal","title":"Colis\u00e3o Horizontal","text":"<pre><code>def handle_horizontal_collision(self, new_x, current_y, tiles):\n    player_rect = (\n        new_x * SPRITE_BLOCK_SIZE,\n        current_y * SPRITE_BLOCK_SIZE,\n        self.width,\n        self.height,\n    )\n    for tile in tiles:\n        if tile.collidable_horizontal:\n            for position in tile.position:\n                tile_rect = (\n                    position[0] * SPRITE_BLOCK_SIZE,\n                    position[1] * SPRITE_BLOCK_SIZE,\n                    tile.width,\n                    tile.height,\n                )\n                if self.check_collision(player_rect, tile_rect):\n                    return self.x  # Reset x position if collision detected\n    return new_x  # Otherwise, return new x position\n</code></pre> <p>Este m\u00e9todo verifica colis\u00f5es horizontais: 1. Cria um ret\u00e2ngulo representando o jogador na nova posi\u00e7\u00e3o horizontal 2. Verifica colis\u00f5es com todos os tiles marcados como <code>collidable_horizontal</code> 3. Se uma colis\u00e3o for detectada, mant\u00e9m a posi\u00e7\u00e3o X atual do jogador 4. Caso contr\u00e1rio, permite o movimento para a nova posi\u00e7\u00e3o X</p>"},{"location":"entidades/#colisao-vertical","title":"Colis\u00e3o Vertical","text":"<pre><code>def handle_vertical_collision(self, current_x, new_y, tiles, delta_time):\n    player_rect = (\n        current_x * SPRITE_BLOCK_SIZE,\n        new_y * SPRITE_BLOCK_SIZE,\n        self.width,\n        self.height,\n    )\n    for tile in tiles:\n        if tile.collidable_vertical:\n            for position in tile.position:\n                tile_rect = (\n                    position[0] * SPRITE_BLOCK_SIZE,\n                    position[1] * SPRITE_BLOCK_SIZE,\n                    tile.width,\n                    tile.height,\n                )\n                if self.check_collision(player_rect, tile_rect):\n                    player_top = round(self.y) * SPRITE_BLOCK_SIZE\n                    player_bottom = (\n                        round(self.y) * SPRITE_BLOCK_SIZE + SPRITE_BLOCK_SIZE * 2\n                    )\n\n                    tile_top = tile_rect[1]\n                    tile_bottom = tile_rect[1] + tile_rect[3]\n\n                    # Colidindo \"por cima\"\n                    if self.vertical_velocity &gt; 0 and self.state != \"descend\":\n                        # Plataforma est\u00e1 abaixo do p\u00e9 do personagem?\n                        if player_bottom &lt;= tile_top:\n                            self.on_ground = True\n                            self.vertical_velocity = 0\n                            return round(self.y)\n                    # Colidindo \"por baixo\"\n                    elif self.vertical_velocity &lt; 0:\n                        pass\n\n    if not self.on_ground:\n        self.vertical_velocity += self.gravity * delta_time\n\n    return new_y  # Caso contr\u00e1rio, retorna a nova posi\u00e7\u00e3o y\n</code></pre> <p>Este m\u00e9todo lida com colis\u00f5es verticais com mais detalhe: 1. Verifica colis\u00f5es com tiles marcados como <code>collidable_vertical</code> 2. Distingue entre colis\u00f5es por cima (jogador aterrissando na plataforma) e por baixo (jogador batendo a cabe\u00e7a) 3. Quando o jogador atinge uma plataforma por cima:    - Define <code>on_ground</code> como verdadeiro    - Zera a velocidade vertical    - Mant\u00e9m a posi\u00e7\u00e3o Y atual 4. Se n\u00e3o houver colis\u00e3o e o jogador n\u00e3o estiver no ch\u00e3o, aplica gravidade 5. Retorna a nova posi\u00e7\u00e3o Y (ajustada devido \u00e0 colis\u00e3o)</p>"},{"location":"entidades/#descida-atraves-de-plataformas","title":"Descida atrav\u00e9s de Plataformas","text":"<pre><code># L\u00f3gica de descida\nif (\n    input_handler.is_pressed(\"down\")\n    and self.on_ground\n    and (state == \"idle\" or state == \"run\")\n):\n    for tile in tiles:\n        if tile.can_descend:\n            for position in tile.position:\n                tile_rect = (\n                    position[0] * SPRITE_BLOCK_SIZE,\n                    position[1] * SPRITE_BLOCK_SIZE,\n                    tile.width,\n                    tile.height,\n                )\n                player_rect = (\n                    self.x * SPRITE_BLOCK_SIZE,\n                    self.y * SPRITE_BLOCK_SIZE\n                    + 0.2,  # Checar logo abaixo do jogador\n                    self.width,\n                    self.height,\n                )\n                if self.check_collision(player_rect, tile_rect):\n                    self.state = \"descend\"\n                    self.on_ground = False\n                    self.vertical_velocity = self.gravity * delta_time\n                    self.descend_time_current = 0\n                    return\n</code></pre> <p>Esta l\u00f3gica permite que o jogador des\u00e7a atrav\u00e9s de plataformas atravess\u00e1veis: 1. Verifica se o jogador est\u00e1 pressionando para baixo, est\u00e1 no ch\u00e3o e em um estado apropriado 2. Verifica se o jogador est\u00e1 sobre uma plataforma com <code>can_descend</code> ativado 3. Se verdadeiro, altera o estado para \"descend\", permite a queda e inicia um temporizador de descida</p>"},{"location":"entidades/#ciclo-de-atualizacao-de-entidades","title":"Ciclo de Atualiza\u00e7\u00e3o de Entidades","text":"<p>O processo de atualiza\u00e7\u00e3o de entidades ocorre a cada quadro do jogo:</p> <ol> <li> <p>Game Loop (em <code>main.py</code>):    <code>python    while running:        delta_time = clock.tick(60) / 1000.0        input_handler.process_events()        game.update(delta_time, input_handler)        game.render(game.screen)        pygame.display.update()</code></p> </li> <li> <p>Game Update (em <code>game.py</code>):    <code>python    def update(self, delta_time, input_handler):        if self.background:            self.background.update(delta_time)        if self.item:            self.item.update(delta_time)        if self.platform:            self.platform.update(delta_time)        if self.player:            self.player.update(delta_time, input_handler, self.platform.tiles)</code></p> </li> <li> <p>Entity Update (em <code>entity.py</code> e classes derivadas):</p> </li> <li>Entidades b\u00e1sicas apenas atualizam anima\u00e7\u00f5es</li> <li>O jogador tem l\u00f3gica adicional para movimento, f\u00edsica e colis\u00f5es</li> </ol> <p>Este padr\u00e3o de atualiza\u00e7\u00e3o em cascata garante que todas as entidades sejam processadas a cada quadro, com l\u00f3gica espec\u00edfica implementada nas subclasses conforme necess\u00e1rio.</p>"},{"location":"entidades/#resumo-do-sistema-de-entidades","title":"Resumo do Sistema de Entidades","text":"<p>O sistema de entidades do 2Do fornece:</p> <ol> <li>Abstra\u00e7\u00e3o flex\u00edvel: A classe <code>Entity</code> serve como base para todos os objetos interativos</li> <li>Anima\u00e7\u00e3o simples: Suporte incorporado para animar sprites atrav\u00e9s da classe <code>Tile</code></li> <li>Detec\u00e7\u00e3o de colis\u00e3o: M\u00e9todos para verificar e responder a colis\u00f5es entre entidades</li> <li>F\u00edsica b\u00e1sica: Implementa\u00e7\u00e3o de gravidade, salto e movimento para o jogador</li> <li>Extensibilidade: Facilidade para adicionar novos tipos de entidades herdando da classe base</li> </ol> <p>Esta arquitetura torna o 2Do adequado para desenvolver jogos de plataforma 2D com diversos tipos de objetos interativos, mantendo o c\u00f3digo organizado e modular.</p>"},{"location":"entidades/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Agora que voc\u00ea compreende o sistema de entidades, pode explorar:</p> <ul> <li>L\u00f3gica de Jogo e Jogador - Detalhes sobre a implementa\u00e7\u00e3o do personagem jog\u00e1vel</li> <li>Sistema de Entrada e Controle - Como o jogo processa entrada do usu\u00e1rio</li> <li>Sistema de Gerenciamento de Recursos - Como os recursos s\u00e3o carregados e utilizados pelas entidades</li> </ul>"},{"location":"estrutura_projeto/","title":"Estrutura do Projeto 2Do","text":"<p>Este documento apresenta a estrutura de diret\u00f3rios e arquivos do projeto, explicando a fun\u00e7\u00e3o de cada componente e como eles se integram para formar o motor de jogos de plataforma 2D.</p>"},{"location":"estrutura_projeto/#visao-geral-da-estrutura","title":"Vis\u00e3o Geral da Estrutura","text":"<p>O 2Do \u00e9 organizado seguindo um design modular, onde cada arquivo tem uma responsabilidade espec\u00edfica. Esta abordagem facilita a manuten\u00e7\u00e3o e expans\u00e3o do c\u00f3digo. A estrutura b\u00e1sica do projeto \u00e9 a seguinte:</p> <pre><code>2Do/\n\u251c\u2500\u2500 asset_manager.py       # Gerenciamento de recursos\n\u251c\u2500\u2500 background.py          # Sistema de plano de fundo\n\u251c\u2500\u2500 config.ini             # Configura\u00e7\u00f5es do jogo\n\u251c\u2500\u2500 entity.py              # Classes base para entidades\n\u251c\u2500\u2500 game.py                # N\u00facleo do motor de jogo\n\u251c\u2500\u2500 input_handler.py       # Processamento de entrada\n\u251c\u2500\u2500 item.py                # Sistema de itens \n\u251c\u2500\u2500 main.py                # Ponto de entrada\n\u251c\u2500\u2500 platformer.py          # Sistema de plataformas\n\u251c\u2500\u2500 player.py              # Implementa\u00e7\u00e3o do jogador\n\u251c\u2500\u2500 readme.md              # Documenta\u00e7\u00e3o geral\n\u251c\u2500\u2500 requirements.txt       # Depend\u00eancias do projeto\n\u251c\u2500\u2500 utils.py               # Fun\u00e7\u00f5es utilit\u00e1rias\n\u251c\u2500\u2500 docs/                  # Documenta\u00e7\u00e3o detalhada\n\u2514\u2500\u2500 site/                  # Documenta\u00e7\u00e3o compilada\n</code></pre>"},{"location":"estrutura_projeto/#componentes-principais","title":"Componentes Principais","text":""},{"location":"estrutura_projeto/#arquivos-essenciais","title":"Arquivos Essenciais","text":""},{"location":"estrutura_projeto/#mainpy","title":"main.py","text":"<p>Este \u00e9 o ponto de entrada do jogo. Suas principais responsabilidades s\u00e3o:</p> <ul> <li>Inicializar a biblioteca Pygame</li> <li>Carregar as configura\u00e7\u00f5es do arquivo <code>config.ini</code></li> <li>Criar a inst\u00e2ncia do jogo e configurar a tela</li> <li>Implementar o loop principal que mant\u00e9m o jogo em execu\u00e7\u00e3o</li> <li>Gerenciar o tempo entre frames (delta)</li> <li>Finalizar o Pygame ao encerrar o jogo</li> </ul> <pre><code># Trecho de exemplo do main.py\npygame.init()\npygame.font.init()\n\nconfig_parser = read_config_file(\"config.ini\")\n\ngame = Game(config_parser=config_parser)\ngame.load_screen()\ngame.load_level(\"maps/level1.tmx\")\n\n# Loop principal\nwhile running:\n    delta_time = clock.tick(60) / 1000.0\n    input_handler.process_events()\n    game.update(delta_time, input_handler)\n    game.render(game.screen)\n    pygame.display.update()\n</code></pre>"},{"location":"estrutura_projeto/#gamepy","title":"game.py","text":"<p>A classe <code>Game</code> atua como o controlador central do motor, respons\u00e1vel por:</p> <ul> <li>Carregar e gerenciar os n\u00edveis do jogo (usando PyTMX)</li> <li>Coordenar a atualiza\u00e7\u00e3o e renderiza\u00e7\u00e3o de todas as entidades</li> <li>Gerenciar a tela do jogo e o modo de exibi\u00e7\u00e3o</li> <li>Intermediar a comunica\u00e7\u00e3o entre os diferentes subsistemas</li> </ul>"},{"location":"estrutura_projeto/#configini","title":"config.ini","text":"<p>Este arquivo de configura\u00e7\u00e3o em formato INI permite personalizar v\u00e1rios aspectos do jogo sem modificar o c\u00f3digo:</p> <ul> <li>Configura\u00e7\u00f5es gr\u00e1ficas (resolu\u00e7\u00e3o, modo de tela)</li> <li>Configura\u00e7\u00f5es de \u00e1udio</li> <li>Defini\u00e7\u00f5es do plano de fundo</li> <li>Mapeamento de controles</li> </ul>"},{"location":"estrutura_projeto/#sistemas-principais","title":"Sistemas Principais","text":""},{"location":"estrutura_projeto/#asset_managerpy","title":"asset_manager.py","text":"<p>O <code>AssetManager</code> \u00e9 respons\u00e1vel por carregar e organizar todos os recursos do jogo, como sprites, tiles e mapas. Ele:</p> <ul> <li>Carrega tiles e sprites a partir de arquivos TMX (formato Tiled Map Editor)</li> <li>Organiza os recursos por tipo (Player, Item, Platform)</li> <li>Extrai propriedades dos tiles (colis\u00e3o, anima\u00e7\u00e3o)</li> <li>Fornece m\u00e9todos para acessar os recursos carregados</li> </ul>"},{"location":"estrutura_projeto/#entitypy","title":"entity.py","text":"<p>Este m\u00f3dulo define as classes base para todos os objetos interativos do jogo:</p> <ul> <li><code>Tile</code>: Representa um \u00fanico tile com propriedades como posi\u00e7\u00e3o, sprites e colis\u00e3o</li> <li><code>Entity</code>: Classe base que representa objetos interativos no mundo do jogo (como personagens, plataformas e itens), gerenciando seu comportamento, estado e intera\u00e7\u00f5es</li> </ul>"},{"location":"estrutura_projeto/#playerpy","title":"player.py","text":"<p>Implementa o personagem controlado pelo jogador, estendendo a classe <code>Entity</code> com:</p> <ul> <li>Movimenta\u00e7\u00e3o completa (horizontal e vertical)</li> <li>Sistema de f\u00edsica (gravidade, salto, queda)</li> <li>Anima\u00e7\u00f5es baseadas no estado atual (idle, run, jump)</li> <li>Detec\u00e7\u00e3o de colis\u00e3o com plataformas</li> <li>Capacidade de descer atrav\u00e9s de plataformas espec\u00edficas</li> </ul>"},{"location":"estrutura_projeto/#input_handlerpy","title":"input_handler.py","text":"<p>Gerencia a entrada do usu\u00e1rio, abstraindo o mapeamento entre teclas f\u00edsicas e a\u00e7\u00f5es no jogo:</p> <ul> <li>Processa eventos do Pygame (teclado, sa\u00edda)</li> <li>Mapeia teclas para a\u00e7\u00f5es (movimento, pulo)</li> <li>Fornece m\u00e9todos para verificar quais teclas est\u00e3o pressionadas</li> <li>Permite alternar entre modo janela e tela cheia</li> </ul>"},{"location":"estrutura_projeto/#backgroundpy","title":"background.py","text":"<p>Gerencia o plano de fundo do jogo, incluindo:</p> <ul> <li>Carregamento e ajuste de imagens de fundo</li> <li>Rolagem paralaxe (efeito de profundidade)</li> <li>Repeti\u00e7\u00e3o (tiling) para cobrir toda a \u00e1rea vis\u00edvel</li> </ul>"},{"location":"estrutura_projeto/#platformerpy-e-itempy","title":"platformer.py e item.py","text":"<p>Implementam os sistemas de plataformas e itens do jogo, estendendo a classe <code>Entity</code> com comportamentos espec\u00edficos para:</p> <ul> <li>Plataformas: superf\u00edcies que o jogador pode andar</li> <li>Itens: objetos colet\u00e1veis ou interativos</li> </ul>"},{"location":"estrutura_projeto/#utilspy","title":"utils.py","text":"<p>Cont\u00e9m fun\u00e7\u00f5es utilit\u00e1rias usadas em v\u00e1rios m\u00f3dulos:</p> <ul> <li>Renderiza\u00e7\u00e3o de informa\u00e7\u00f5es de depura\u00e7\u00e3o (FPS)</li> <li>Leitura de arquivos de configura\u00e7\u00e3o</li> <li>Outras fun\u00e7\u00f5es auxiliares</li> </ul>"},{"location":"estrutura_projeto/#fluxo-de-execucao","title":"Fluxo de Execu\u00e7\u00e3o","text":"<p>O fluxo t\u00edpico do 2Do segue esta sequ\u00eancia:</p> <ol> <li>Inicializa\u00e7\u00e3o (<code>main.py</code>):</li> <li>Inicializa o Pygame e suas depend\u00eancias</li> <li>Carrega as configura\u00e7\u00f5es do <code>config.ini</code></li> <li> <p>Cria a inst\u00e2ncia do jogo e configura a tela</p> </li> <li> <p>Carregamento do Jogo (<code>game.py</code>):</p> </li> <li>Carrega o n\u00edvel usando o <code>AssetManager</code></li> <li>Inicializa o plano de fundo</li> <li> <p>Cria as entidades (jogador, plataformas, itens)</p> </li> <li> <p>Loop Principal (<code>main.py</code>):</p> </li> <li>Captura o tempo entre frames (delta)</li> <li>Processa eventos de entrada do usu\u00e1rio (<code>InputHandler</code>)</li> <li>Atualiza o estado do jogo (<code>Game.update()</code>)</li> <li>Renderiza todos os elementos na tela (<code>Game.render()</code>)</li> <li> <p>Atualiza a exibi\u00e7\u00e3o</p> </li> <li> <p>Atualiza\u00e7\u00e3o de Estado (<code>game.py</code> \u2192 v\u00e1rios componentes):</p> </li> <li>Atualiza o plano de fundo (rolagem)</li> <li>Atualiza as plataformas e itens (anima\u00e7\u00f5es)</li> <li> <p>Atualiza o jogador (f\u00edsica, colis\u00f5es, anima\u00e7\u00f5es)</p> </li> <li> <p>Renderiza\u00e7\u00e3o (<code>game.py</code> \u2192 v\u00e1rios componentes):</p> </li> <li>Renderiza o plano de fundo</li> <li>Renderiza as plataformas e itens</li> <li>Renderiza o jogador</li> <li>Renderiza informa\u00e7\u00f5es de depura\u00e7\u00e3o (FPS)</li> </ol>"},{"location":"estrutura_projeto/#dependencias-entre-componentes","title":"Depend\u00eancias entre Componentes","text":"<p>O 2Do foi projetado com uma clara separa\u00e7\u00e3o de responsabilidades, mas seus componentes precisam colaborar para formar um sistema coeso:</p> <ul> <li>Depend\u00eancias Verticais:</li> <li><code>main.py</code> \u2192 <code>game.py</code> \u2192 entidades espec\u00edficas (<code>player.py</code>, <code>item.py</code>, etc.)</li> <li> <p>Componentes de mais alto n\u00edvel coordenam os de n\u00edvel inferior</p> </li> <li> <p>Depend\u00eancias Horizontais:</p> </li> <li><code>player.py</code> depende de <code>platformer.py</code> para detec\u00e7\u00e3o de colis\u00e3o</li> <li>Todas as entidades dependem de <code>entity.py</code> para funcionalidade base</li> <li> <p>V\u00e1rios componentes dependem de <code>utils.py</code> para fun\u00e7\u00f5es auxiliares</p> </li> <li> <p>Ponto Central:</p> </li> <li><code>game.py</code> atua como o \"maestro\" que coordena todos os outros componentes</li> <li><code>asset_manager.py</code> fornece recursos para v\u00e1rios componentes</li> </ul> <p>Esta estrutura facilita a expans\u00e3o do motor, permitindo adicionar novos tipos de entidades ou sistemas com impacto m\u00ednimo no c\u00f3digo existente.</p>"},{"location":"estrutura_projeto/#ferramentas-de-desenvolvimento","title":"Ferramentas de Desenvolvimento","text":"<ul> <li>Documenta\u00e7\u00e3o: O 2Do usa MkDocs com o tema Material para gerar documenta\u00e7\u00e3o a partir de arquivos Markdown</li> <li>Estrutura de Diret\u00f3rios: </li> <li><code>docs/</code>: Cont\u00e9m os arquivos Markdown da documenta\u00e7\u00e3o</li> <li><code>site/</code>: Cont\u00e9m a documenta\u00e7\u00e3o HTML gerada pelo MkDocs</li> </ul>"},{"location":"estrutura_projeto/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Agora que voc\u00ea compreende a estrutura do projeto, pode explorar:</p> <ul> <li>Sistema de Gerenciamento de Recursos - Como o 2Do carrega e gerencia sprites e tiles</li> <li>Entidades e Objetos do Jogo - Detalhes sobre o sistema de entidades </li> <li>Sistema de Entrada e Controle - Como personalizar os controles do jogo</li> <li>L\u00f3gica de Jogo e Jogador - F\u00edsica e mec\u00e2nicas do jogador</li> </ul>"},{"location":"executando/","title":"Executando o 2Do","text":"<p>Este guia explica como configurar o ambiente de desenvolvimento, executar o jogo e entender o fluxo b\u00e1sico de funcionamento do 2Do.</p>"},{"location":"executando/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Antes de executar o 2Do, certifique-se de que seu sistema atende aos seguintes requisitos:</p> <ul> <li>Python 3.8 ou superior: Download Python</li> <li>Git: Download Git</li> <li>Depend\u00eancias do Projeto: Instale as bibliotecas necess\u00e1rias listadas no arquivo <code>requirements.txt</code>.</li> </ul>"},{"location":"executando/#configurando-o-ambiente","title":"Configurando o Ambiente","text":""},{"location":"executando/#1-clonar-o-repositorio","title":"1. Clonar o Reposit\u00f3rio","text":"<p>Para come\u00e7ar, clone o reposit\u00f3rio do 2Do para o seu ambiente local:</p> <pre><code>git clone https://github.com/seu-usuario/2Do.git\ncd 2Do\n</code></pre>"},{"location":"executando/#2-instalar-dependencias","title":"2. Instalar Depend\u00eancias","text":"<p>Instale as depend\u00eancias do projeto usando o <code>pip</code>:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Isso garantir\u00e1 que todas as bibliotecas necess\u00e1rias, como Pygame e PyTMX, estejam instaladas.</p>"},{"location":"executando/#executando-o-jogo","title":"Executando o Jogo","text":""},{"location":"executando/#1-iniciar-o-jogo","title":"1. Iniciar o Jogo","text":"<p>Para executar o jogo, navegue at\u00e9 o diret\u00f3rio do projeto e execute o arquivo <code>main.py</code>:</p> <pre><code>python main.py\n</code></pre> <p>Isso iniciar\u00e1 o jogo e exibir\u00e1 a tela inicial.</p>"},{"location":"executando/#2-controles-do-jogo","title":"2. Controles do Jogo","text":"<p>O jogo utiliza os seguintes controles padr\u00e3o:</p> <ul> <li>Movimenta\u00e7\u00e3o:</li> <li>Setas direcionais ou WASD: Movimentar o personagem.</li> <li>Espa\u00e7o: Pular.</li> <li>Tela Cheia:</li> <li>F11: Alternar entre tela cheia e modo janela.</li> <li>Sair do Jogo:</li> <li>ESC: Fechar o jogo.</li> </ul>"},{"location":"executando/#3-configuracoes-personalizadas","title":"3. Configura\u00e7\u00f5es Personalizadas","text":"<p>Voc\u00ea pode personalizar os controles e outras configura\u00e7\u00f5es editando o arquivo <code>config.ini</code>. Para mais detalhes, consulte o guia Configura\u00e7\u00e3o do Jogo.</p>"},{"location":"executando/#fluxo-de-execucao","title":"Fluxo de Execu\u00e7\u00e3o","text":"<p>O fluxo b\u00e1sico de execu\u00e7\u00e3o do 2Do \u00e9 o seguinte:</p> <ol> <li>Inicializa\u00e7\u00e3o:</li> <li>O jogo carrega o arquivo de configura\u00e7\u00e3o (<code>config.ini</code>) e inicializa o Pygame.</li> <li> <p>O <code>AssetManager</code> carrega os recursos do jogo, como sprites, tiles e mapas.</p> </li> <li> <p>Carregamento do N\u00edvel:</p> </li> <li>O jogo carrega o n\u00edvel a partir de um arquivo TMX (gerado pelo Tiled Map Editor).</li> <li> <p>As entidades do jogo (player, itens, plataformas) s\u00e3o inicializadas.</p> </li> <li> <p>Loop Principal:</p> </li> <li>O <code>InputHandler</code> processa a entrada do usu\u00e1rio.</li> <li>O <code>Game</code> atualiza o estado do jogo (f\u00edsica, colis\u00f5es, anima\u00e7\u00f5es).</li> <li>O <code>Background</code> atualiza e renderiza o plano de fundo.</li> <li> <p>Todas as entidades s\u00e3o renderizadas na tela.</p> </li> <li> <p>Finaliza\u00e7\u00e3o:</p> </li> <li>Quando o jogo \u00e9 encerrado, o Pygame \u00e9 finalizado e os recursos s\u00e3o liberados.</li> </ol>"},{"location":"executando/#solucao-de-problemas","title":"Solu\u00e7\u00e3o de Problemas","text":""},{"location":"executando/#1-erro-ao-executar-o-jogo","title":"1. Erro ao Executar o Jogo","text":"<p>Se o jogo n\u00e3o iniciar, verifique se todas as depend\u00eancias foram instaladas corretamente. Execute o seguinte comando para garantir:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"executando/#2-problemas-com-assets","title":"2. Problemas com Assets","text":"<p>Se os assets (sprites, tiles, etc.) n\u00e3o forem carregados corretamente, verifique se os caminhos no arquivo <code>config.ini</code> est\u00e3o corretos e se os arquivos existem no diret\u00f3rio especificado.</p>"},{"location":"executando/#3-erros-de-renderizacao","title":"3. Erros de Renderiza\u00e7\u00e3o","text":"<p>Se houver problemas de renderiza\u00e7\u00e3o, como telas em branco ou elementos faltando, verifique se o arquivo TMX do n\u00edvel est\u00e1 configurado corretamente e se todas as camadas est\u00e3o vis\u00edveis.</p>"},{"location":"executando/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Agora que voc\u00ea sabe como executar o 2Do, explore outros t\u00f3picos da documenta\u00e7\u00e3o para aprofundar seu conhecimento:</p> <ul> <li>Gerenciamento de Assets</li> <li>Controles do Jogo</li> <li>Entidades do Jogo</li> </ul>"},{"location":"logica_jogo/","title":"L\u00f3gica de Jogo e Jogador","text":"<p>Este documento explora a l\u00f3gica central do 2Do, focando em como o jogo \u00e9 inicializado, gerenciado e como o jogador interage com o mundo do jogo. Entender estes aspectos \u00e9 fundamental para quem deseja personalizar ou expandir o motor.</p>"},{"location":"logica_jogo/#arquitetura-da-logica-de-jogo","title":"Arquitetura da L\u00f3gica de Jogo","text":"<p>O 2Do implementa um modelo cl\u00e1ssico de jogo de plataforma 2D, com estes componentes principais:</p> <ol> <li>Ciclo de jogo: Mant\u00e9m o jogo em execu\u00e7\u00e3o, sincronizando atualiza\u00e7\u00f5es e renderiza\u00e7\u00e3o</li> <li>Sistema de f\u00edsica: Implementa gravidade, movimento e colis\u00f5es </li> <li>M\u00e1quina de estados: Gerencia os diferentes estados do jogador (parado, correndo, pulando)</li> <li>Controle do jogador: Processa entrada do usu\u00e1rio e atualiza o estado do jogador</li> </ol> <p>Estes sistemas trabalham juntos para criar a experi\u00eancia de jogo, com c\u00f3digo distribu\u00eddo principalmente entre os arquivos <code>game.py</code> e <code>player.py</code>.</p>"},{"location":"logica_jogo/#inicializacao-e-ciclo-do-jogo","title":"Inicializa\u00e7\u00e3o e Ciclo do Jogo","text":""},{"location":"logica_jogo/#ponto-de-entrada","title":"Ponto de Entrada","text":"<p>A inicializa\u00e7\u00e3o do 2Do come\u00e7a no arquivo <code>main.py</code>, que configura o ambiente e inicia o ciclo principal:</p> <pre><code>pygame.init()\npygame.font.init()\n\nconfig_parser = read_config_file(\"config.ini\")\n\ngame = Game(config_parser=config_parser)\ngame.load_screen()\ngame.load_level(\"maps/level1.tmx\")\n\ninput_handler = InputHandler(config_parser)\n\nclock = pygame.time.Clock()\nrunning = True\n\nwhile running:\n    delta_time = clock.tick(60) / 1000.0\n\n    input_handler.process_events()\n    if input_handler.quit_game:\n        running = False\n\n    game.update(delta_time, input_handler)\n    game.screen.fill((0, 0, 0))\n    game.render(game.screen)\n    render_fps(clock.get_fps(), game.screen, font)\n\n    pygame.display.update()\n</code></pre> <p>Este c\u00f3digo: 1. Inicializa o Pygame e seus subsistemas 2. Carrega as configura\u00e7\u00f5es do arquivo <code>config.ini</code> 3. Cria uma inst\u00e2ncia da classe <code>Game</code> 4. Configura a tela e carrega o n\u00edvel inicial 5. Cria um manipulador de entrada para processar as a\u00e7\u00f5es do jogador 6. Inicia o ciclo principal (game loop) que executar\u00e1 at\u00e9 o jogo ser encerrado</p>"},{"location":"logica_jogo/#compreendendo-o-delta","title":"Compreendendo o Delta","text":"<p>Uma parte crucial do ciclo de jogo \u00e9 o c\u00e1lculo do <code>delta_time</code>:</p> <pre><code>delta_time = clock.tick(60) / 1000.0\n</code></pre> <p>O delta representa o tempo real decorrido (em segundos) desde o \u00faltimo quadro de anima\u00e7\u00e3o (frame). Este conceito \u00e9 fundamental para criar movimentos consistentes independentemente da velocidade do hardware.</p> <p>Por que o delta \u00e9 importante?</p> <p>Sem usar o delta, o movimento seria baseado em quadros, n\u00e3o em tempo real:</p> <ul> <li>Em um computador potente executando a 120 FPS: uma anima\u00e7\u00e3o ocorreria duas vezes mais r\u00e1pido</li> <li>Em um computador lento executando a 30 FPS: a mesma anima\u00e7\u00e3o seria duas vezes mais lenta</li> </ul> <p>Como o 2Do utiliza o delta:</p> <p>No 2Do, todas as atualiza\u00e7\u00f5es de movimento e f\u00edsica recebem o delta como par\u00e2metro:</p> <pre><code># No m\u00e9todo update do player\ndef update(self, delta_time, input_handler, tiles):\n    self.update_state_and_velocity(input_handler, delta_time, tiles)\n    self.update_position(delta_time, tiles)\n    self.update_animation_frames(delta_time)\n</code></pre> <p>Internamente, o delta \u00e9 aplicado nas opera\u00e7\u00f5es de movimento:</p> <pre><code># Trecho real da atualiza\u00e7\u00e3o de posi\u00e7\u00e3o no 2Do\nnew_x = self.x + self.velocity * delta_time\nnew_y = self.y + self.vertical_velocity * delta_time\n</code></pre> <p>Exemplo ilustrativo:</p> <p>Para entender o conceito, considere dois cen\u00e1rios hipot\u00e9ticos:</p> <ol> <li> <p>Sem delta (incorreto):    <code>python    # A cada frame, o personagem sempre se move 5 pixels    position_x += 5</code></p> </li> <li> <p>Com delta (como no 2Do):    <code>python    # O personagem se move a uma velocidade constante de 300 pixels por segundo    position_x += 300 * delta_time</code></p> </li> </ol> <p>No segundo caso: - Em um frame que leva 1/60s (0.0167s): <code>position_x += 300 * 0.0167 = 5 pixels</code> - Em um frame que leva 1/30s (0.0333s): <code>position_x += 300 * 0.0333 = 10 pixels</code></p> <p>Isto garante que, independentemente da taxa de quadros, o personagem sempre se move \u00e0 mesma velocidade real, criando uma experi\u00eancia consistente em diferentes hardwares.</p>"},{"location":"logica_jogo/#a-classe-game","title":"A Classe Game","text":"<p>A classe <code>Game</code> (no arquivo <code>game.py</code>) gerencia o estado global do jogo:</p> <pre><code>class Game:\n    def __init__(self, config_parser, width=800, height=600):\n        self.config_parser = config_parser\n        resolution_str = self.config_parser.get(\"graphics\", \"resolution\", fallback=\"1280x720\")\n        self.width, self.height = map(int, resolution_str.split(\"x\"))\n        self.is_fullscreen = self.config_parser.get(\"graphics\", \"fullscreen\", fallback=\"no\").lower() == \"yes\"\n        self.screen = None\n        self.background = None\n        self.screen_needs_update = True\n</code></pre> <p>Durante a inicializa\u00e7\u00e3o, esta classe: 1. Carrega as configura\u00e7\u00f5es de resolu\u00e7\u00e3o e modo de exibi\u00e7\u00e3o 2. Configura a tela com base nessas configura\u00e7\u00f5es 3. Prepara vari\u00e1veis para armazenar o estado do jogo (fundo, entidades)</p>"},{"location":"logica_jogo/#carregamento-de-niveis","title":"Carregamento de N\u00edveis","text":"<p>O m\u00e9todo <code>load_level</code> \u00e9 respons\u00e1vel por carregar os arquivos TMX (criados com o Tiled Map Editor) e inicializar as entidades do jogo:</p> <pre><code>def load_level(self, level_filename):\n    try:\n        self.tiled_level = pytmx.load_pygame(level_filename)\n        self.load_assets()\n        self.background = Background(self.tiled_level, self.config_parser)\n    except Exception as e:\n        print(f\"Erro ao carregar o n\u00edvel: {e}\")\n\ndef load_assets(self):\n    self.asset_manager = AssetManager(self.tiled_level)\n    self.player = Player(self.asset_manager.get_asset(\"Player\"))\n    self.item = Item(self.asset_manager.get_asset(\"Item\"))\n    self.platform = Platform(self.asset_manager.get_asset(\"Platform\"))\n</code></pre> <p>Este processo: 1. Carrega o arquivo de mapa usando PyTMX 2. Cria um gerenciador de assets para extrair recursos do mapa 3. Inicializa as entidades do jogo (jogador, itens, plataformas) 4. Configura o plano de fundo com base no mapa e configura\u00e7\u00f5es</p>"},{"location":"logica_jogo/#o-jogador-e-sua-interacao-com-o-mundo","title":"O Jogador e sua Intera\u00e7\u00e3o com o Mundo","text":"<p>A classe <code>Player</code> (arquivo <code>player.py</code>) \u00e9 o cora\u00e7\u00e3o da jogabilidade, gerenciando o personagem control\u00e1vel.</p>"},{"location":"logica_jogo/#inicializacao-do-jogador","title":"Inicializa\u00e7\u00e3o do Jogador","text":"<pre><code>class Player(Entity):\n    def __init__(self, data):\n        super().__init__(data)\n\n        self.state = \"idle\"\n        self.face_direction = \"right\"\n        self.x = self.tiles[0].position[0][0]\n        self.y = self.tiles[0].position[0][1]\n\n        self.width = self.tiles[0].width\n        self.height = self.tiles[0].height\n\n        self.velocity = 0.0\n        self.max_velocity = 12.0\n        self.acceleration = 1.0\n        self.deceleration = 8.0\n\n        self.vertical_velocity = 0.0\n        self.jump_acceleration = -24.0\n        self.gravity = 35\n        self.on_ground = True\n\n        self.jump_time_max = 0.2\n        self.jump_time_current = 0\n\n        self.descend_time_max = 0.12\n        self.descend_time_current = 0\n</code></pre> <p>Esta inicializa\u00e7\u00e3o configura: 1. Estado inicial: Come\u00e7a no estado \"idle\" (parado), virado para a direita 2. Posi\u00e7\u00e3o: Definida pela posi\u00e7\u00e3o do primeiro tile do jogador no mapa 3. Tamanho: Largura e altura para detec\u00e7\u00e3o de colis\u00e3o 4. Par\u00e2metros de movimento horizontal: Velocidade, acelera\u00e7\u00e3o e desacelera\u00e7\u00e3o 5. Par\u00e2metros de movimento vertical: Gravidade, for\u00e7a de salto e detec\u00e7\u00e3o de ch\u00e3o 6. Par\u00e2metros de tempo: Dura\u00e7\u00e3o m\u00e1xima do salto e do tempo de descida</p>"},{"location":"logica_jogo/#ciclo-de-atualizacao-do-jogador","title":"Ciclo de Atualiza\u00e7\u00e3o do Jogador","text":"<p>O m\u00e9todo <code>update</code> do jogador \u00e9 chamado a cada quadro, coordenando toda a l\u00f3gica do personagem:</p> <pre><code>def update(self, delta_time, input_handler, tiles):\n    self.update_state_and_velocity(input_handler, delta_time, tiles)\n    self.update_position(delta_time, tiles)\n    self.update_animation_frames(delta_time)\n</code></pre> <p>Este m\u00e9todo divide a atualiza\u00e7\u00e3o em tr\u00eas etapas: 1. Atualiza\u00e7\u00e3o de estado e velocidade: Determina a m\u00e1quina de estados e como o jogador deve mover com base em entrada do usu\u00e1rio 2. Atualiza\u00e7\u00e3o de posi\u00e7\u00e3o: Aplica f\u00edsica e detecta colis\u00f5es para determinar a posi\u00e7\u00e3o final 3. Atualiza\u00e7\u00e3o de anima\u00e7\u00e3o: Atualiza os quadros de anima\u00e7\u00e3o com base no estado atual</p>"},{"location":"logica_jogo/#maquina-de-estados-do-jogador","title":"M\u00e1quina de Estados do Jogador","text":"<p>O jogador pode estar em diferentes estados, cada um com comportamento espec\u00edfico:</p> <ul> <li>\"idle\": Parado, sem movimento horizontal</li> <li>\"run\": Movendo-se horizontalmente</li> <li>\"jump\": Subindo ap\u00f3s um salto</li> <li>\"fall\": Caindo ap\u00f3s atingir o \u00e1pice do salto ou cair de uma plataforma</li> <li>\"descend\": Estado especial para descer atrav\u00e9s de plataformas atravess\u00e1veis</li> </ul> <p>A transi\u00e7\u00e3o entre estados acontece em <code>update_state_and_velocity</code>:</p> <pre><code>def update_state_and_velocity(self, input_handler, delta_time, tiles):\n    state = self.state\n\n    # L\u00f3gica de descida\n    if input_handler.is_pressed(\"down\") and self.on_ground and (state == \"idle\" or state == \"run\"):\n        # Verifica se est\u00e1 sobre uma plataforma atravess\u00e1vel e inicia descida\n\n    # L\u00f3gica de movimento horizontal\n    if input_handler.is_pressed(\"left\"):\n        self.face_direction = \"left\"\n        if self.on_ground:\n            self.state = \"run\"\n        self.velocity = max(-self.max_velocity, self.velocity - self.acceleration)\n    elif input_handler.is_pressed(\"right\"):\n        self.face_direction = \"right\"\n        if self.on_ground:\n            self.state = \"run\"\n        self.velocity = min(self.max_velocity, self.velocity + self.acceleration)\n    else:\n        if self.on_ground and (state == \"run\" or state == \"idle\"):\n            self.state = \"idle\"\n            self.apply_deceleration()\n\n    # L\u00f3gica de salto\n    if state != \"jump\" and input_handler.is_pressed(\"up\") and self.on_ground:\n        self.state = \"jump\"\n        self.on_ground = False\n        self.vertical_velocity = self.jump_acceleration\n        self.jump_time_current = 0\n\n    # L\u00f3gica de pulo sustentado\n    if state == \"jump\":\n        if input_handler.is_pressed(\"up\"):\n            self.jump_time_current += delta_time\n            if self.jump_time_current &gt;= self.jump_time_max:\n                self.state = \"fall\"\n        else:\n            self.state = \"fall\"\n\n    # L\u00f3gica de queda\n    if not self.on_ground and state != \"jump\" and state != \"descend\":\n        self.state = \"fall\"\n\n    # Verifica\u00e7\u00e3o de colis\u00e3o vertical\n    if self.on_ground and (self.state == \"fall\" or self.state == \"descend\"):\n        self.state = \"idle\"\n</code></pre> <p>Descri\u00e7\u00e3o da M\u00e1quina de Estados:</p> <p>O jogador no 2Do transita entre cinco estados principais, com regras espec\u00edficas para cada transi\u00e7\u00e3o:</p> <ol> <li>De IDLE (parado):</li> <li>Ao pressionar esquerda/direita: transita para RUN</li> <li>Ao pressionar cima: transita para JUMP</li> <li>Ao pressionar baixo sobre plataforma atravess\u00e1vel: transita para DESCEND</li> <li> <p>Ao perder contato com o solo: transita para FALL</p> </li> <li> <p>De RUN (correndo):</p> </li> <li>Ao soltar as teclas de dire\u00e7\u00e3o: retorna para IDLE</li> <li>Ao pressionar cima: transita para JUMP</li> <li>Ao pressionar baixo sobre plataforma atravess\u00e1vel: transita para DESCEND</li> <li> <p>Ao perder contato com o solo: transita para FALL</p> </li> <li> <p>De JUMP (saltando):</p> </li> <li>Ao soltar a tecla de cima: transita para FALL</li> <li> <p>Ao atingir o tempo m\u00e1ximo de salto: transita para FALL</p> </li> <li> <p>De FALL (caindo):</p> </li> <li> <p>Ao colidir com uma plataforma por cima: transita para IDLE</p> </li> <li> <p>De DESCEND (descendo atrav\u00e9s de plataforma):</p> </li> <li>Ao terminar o tempo de descida: transita para FALL</li> <li>Ao atingir uma plataforma s\u00f3lida: transita para IDLE</li> </ol> <p>As anima\u00e7\u00f5es e comportamentos f\u00edsicos mudam com cada estado, criando uma experi\u00eancia de controle fluida e responsiva.</p> <p>TODO: No futuro, adicionar um diagrama visual da m\u00e1quina de estados para facilitar a compreens\u00e3o das transi\u00e7\u00f5es entre estados do jogador.</p>"},{"location":"logica_jogo/#fisica-de-movimento","title":"F\u00edsica de Movimento","text":"<p>A f\u00edsica do jogador \u00e9 implementada em <code>update_position</code>, que calcula a nova posi\u00e7\u00e3o com base nas velocidades e verifica colis\u00f5es:</p> <pre><code>def update_position(self, delta_time, tiles):\n    new_x, new_y = self.calculate_new_positions(delta_time)\n    new_x = self.handle_horizontal_collision(new_x, self.y, tiles)\n\n    # Atualiza a posi\u00e7\u00e3o Y e a velocidade vertical\n    if self.state == \"jump\":\n        if self.jump_time_current &lt; self.jump_time_max:\n            additional_jump_force = -2 * (self.jump_time_max - self.jump_time_current) / self.jump_time_max\n            self.vertical_velocity += additional_jump_force * self.gravity * delta_time\n    else:\n        self.vertical_velocity += self.gravity * delta_time\n\n    new_y = self.y + self.vertical_velocity * delta_time\n\n    # Descida atrav\u00e9s de plataformas\n    if self.state == \"descend\":\n        self.descend_time_current += delta_time\n        if self.descend_time_current &gt;= self.descend_time_max:\n            self.state = \"fall\"\n\n    new_y = self.handle_vertical_collision(new_x, new_y, tiles, delta_time)\n\n    self.x = new_x\n    self.y = new_y\n</code></pre> <p>Este m\u00e9todo segue estes passos: 1. Calcula posi\u00e7\u00f5es provis\u00f3rias com base nas velocidades atuais 2. Verifica e resolve colis\u00f5es horizontais 3. Aplica gravidade e for\u00e7as adicionais ao movimento vertical 4. Gerencia o estado de descida atrav\u00e9s de plataformas 5. Verifica e resolve colis\u00f5es verticais 6. Atualiza as posi\u00e7\u00f5es finais</p>"},{"location":"logica_jogo/#conceitos-de-fisica-no-jogo","title":"Conceitos de F\u00edsica no Jogo","text":""},{"location":"logica_jogo/#movimento-horizontal","title":"Movimento Horizontal","text":"<p>O movimento horizontal segue um modelo de acelera\u00e7\u00e3o e desacelera\u00e7\u00e3o para criar uma sensa\u00e7\u00e3o de in\u00e9rcia:</p> <pre><code># Acelera\u00e7\u00e3o quando uma tecla de dire\u00e7\u00e3o \u00e9 pressionada\nself.velocity = min(self.max_velocity, self.velocity + self.acceleration)\n\n# Desacelera\u00e7\u00e3o quando nenhuma tecla \u00e9 pressionada\ndef apply_deceleration(self):\n    if self.velocity &gt; 0:\n        self.velocity = max(0, self.velocity - self.deceleration)\n    elif self.velocity &lt; 0:\n        self.velocity = min(0, self.velocity + self.deceleration)\n</code></pre> <p>Este sistema cria um movimento mais natural do que simplesmente definir uma velocidade constante quando uma tecla \u00e9 pressionada.</p>"},{"location":"logica_jogo/#gravidade-e-salto","title":"Gravidade e Salto","text":"<p>O sistema de gravidade \u00e9 baseado em acelera\u00e7\u00e3o constante, assim como na f\u00edsica do mundo real:</p> <pre><code># Aplica gravidade\nself.vertical_velocity += self.gravity * delta_time\n\n# Inicia um salto\nself.vertical_velocity = self.jump_acceleration\n</code></pre> <p>O salto usa um valor negativo de acelera\u00e7\u00e3o (para cima, na coordenada Y do Pygame), enquanto a gravidade constantemente puxa o jogador para baixo.</p>"},{"location":"logica_jogo/#salto-variavel","title":"Salto Vari\u00e1vel","text":"<p>Um detalhe interessante \u00e9 o \"salto vari\u00e1vel\", onde a dura\u00e7\u00e3o do pressionamento da tecla afeta a altura do salto:</p> <pre><code>if self.state == \"jump\":\n    if input_handler.is_pressed(\"up\"):\n        self.jump_time_current += delta_time\n        if self.jump_time_current &gt;= self.jump_time_max:\n            self.state = \"fall\"\n    else:\n        self.state = \"fall\"\n</code></pre> <p>Se o jogador soltar a tecla de salto rapidamente, o personagem come\u00e7ar\u00e1 a cair mais cedo, resultando em um salto mais curto. Isto adiciona mais controle e nuance ao movimento.</p>"},{"location":"logica_jogo/#forca-de-salto-adicional","title":"For\u00e7a de Salto Adicional","text":"<p>O jogador recebe uma for\u00e7a de salto adicional enquanto est\u00e1 subindo:</p> <pre><code>if self.state == \"jump\":\n    if self.jump_time_current &lt; self.jump_time_max:\n        additional_jump_force = -2 * (self.jump_time_max - self.jump_time_current) / self.jump_time_max\n        self.vertical_velocity += additional_jump_force * self.gravity * delta_time\n</code></pre> <p>Esta for\u00e7a diminui gradualmente conforme o jogador se aproxima da dura\u00e7\u00e3o m\u00e1xima do salto, criando uma trajet\u00f3ria mais natural para o usu\u00e1rio.</p>"},{"location":"logica_jogo/#sistema-de-colisao","title":"Sistema de Colis\u00e3o","text":"<p>O jogador interage com o mundo atrav\u00e9s de colis\u00f5es, implementadas em dois m\u00e9todos principais:</p>"},{"location":"logica_jogo/#colisoes-horizontais","title":"Colis\u00f5es Horizontais","text":"<pre><code>def handle_horizontal_collision(self, new_x, current_y, tiles):\n    player_rect = (\n        new_x * SPRITE_BLOCK_SIZE,\n        current_y * SPRITE_BLOCK_SIZE,\n        self.width,\n        self.height,\n    )\n    for tile in tiles:\n        if tile.collidable_horizontal:\n            for position in tile.position:\n                tile_rect = (\n                    position[0] * SPRITE_BLOCK_SIZE,\n                    position[1] * SPRITE_BLOCK_SIZE,\n                    tile.width,\n                    tile.height,\n                )\n                if self.check_collision(player_rect, tile_rect):\n                    return self.x  # Mant\u00e9m posi\u00e7\u00e3o X atual\n    return new_x  # Permite movimento para nova posi\u00e7\u00e3o X\n</code></pre> <p>Este m\u00e9todo verifica se o movimento horizontal levaria a uma colis\u00e3o com alguma plataforma. Se houver colis\u00e3o, o jogador mant\u00e9m sua posi\u00e7\u00e3o atual.</p>"},{"location":"logica_jogo/#colisoes-verticais","title":"Colis\u00f5es Verticais","text":"<pre><code>def handle_vertical_collision(self, current_x, new_y, tiles, delta_time):\n    player_rect = (\n        current_x * SPRITE_BLOCK_SIZE,\n        new_y * SPRITE_BLOCK_SIZE,\n        self.width,\n        self.height,\n    )\n    for tile in tiles:\n        if tile.collidable_vertical:\n            for position in tile.position:\n                tile_rect = (\n                    position[0] * SPRITE_BLOCK_SIZE,\n                    position[1] * SPRITE_BLOCK_SIZE,\n                    tile.width,\n                    tile.height,\n                )\n                if self.check_collision(player_rect, tile_rect):\n                    # Verifica se est\u00e1 caindo sobre a plataforma\n                    if self.vertical_velocity &gt; 0 and self.state != \"descend\":\n                        self.on_ground = True\n                        self.vertical_velocity = 0\n                        return round(self.y)\n\n    # Se n\u00e3o houver colis\u00e3o, continua aplicando gravidade\n    if not self.on_ground:\n        self.vertical_velocity += self.gravity * delta_time\n\n    return new_y\n</code></pre> <p>A detec\u00e7\u00e3o de colis\u00e3o vertical verifica principalmente quando o jogador est\u00e1 caindo sobre uma plataforma:</p> <ol> <li>Verifica se o jogador est\u00e1 em rota de colis\u00e3o com um tile que tenha a propriedade <code>collidable_vertical</code></li> <li>Quando h\u00e1 colis\u00e3o, verifica se o jogador est\u00e1 caindo (<code>vertical_velocity &gt; 0</code>) e n\u00e3o est\u00e1 no estado de descida deliberada</li> <li>Se essas condi\u00e7\u00f5es forem atendidas, o jogador \u00e9 definido como \"no ch\u00e3o\" (<code>on_ground = True</code>)</li> <li>A velocidade vertical \u00e9 zerada, interrompendo a queda</li> <li>O jogador mant\u00e9m sua posi\u00e7\u00e3o Y atual, evitando penetrar na plataforma</li> </ol> <p>Se nenhuma colis\u00e3o for detectada e o jogador n\u00e3o estiver no ch\u00e3o, a gravidade continua sendo aplicada, aumentando a velocidade vertical (acelerando a queda).</p> <p>Esta implementa\u00e7\u00e3o prioriza o caso mais comum em jogos de plataforma: detectar quando o jogador aterrissa em uma superf\u00edcie ap\u00f3s um salto ou queda.</p>"},{"location":"logica_jogo/#renderizacao-e-animacao","title":"Renderiza\u00e7\u00e3o e Anima\u00e7\u00e3o","text":"<p>Ap\u00f3s toda a l\u00f3gica de atualiza\u00e7\u00e3o, o jogo renderiza o estado atual na tela:</p> <pre><code># Em Game.render\ndef render(self, screen):\n    block_size = self.get_block_size()\n\n    if self.background:\n        self.background.render(screen, block_size)\n\n    if self.item:\n        self.item.render(screen, block_size)\n\n    if self.platform:\n        self.platform.render(screen, block_size)\n\n    if self.player:\n        self.player.render(screen, block_size)\n</code></pre> <p>O jogador escolhe qual anima\u00e7\u00e3o mostrar com base em seu estado atual:</p> <pre><code># Em Player.render\ndef render(self, screen, block_size):\n    for tile in self.tiles:\n        if self.state == tile.animation_name:\n            sprite_to_draw = tile.sprites[tile.current_frame]\n\n            if self.face_direction == \"left\":\n                sprite_to_draw = pygame.transform.flip(sprite_to_draw, True, False)\n\n            screen.blit(\n                sprite_to_draw,\n                (self.x * block_size[0], self.y * block_size[1]),\n            )\n</code></pre> <p>Este m\u00e9todo: 1. Encontra o tile com a anima\u00e7\u00e3o correspondente ao estado atual (mesmo nome) 2. Espelha o sprite se o jogador estiver virado para a esquerda 3. Desenha o sprite na posi\u00e7\u00e3o atual do jogador</p>"},{"location":"logica_jogo/#ajustando-a-fisica-do-jogo","title":"Ajustando a F\u00edsica do Jogo","text":"<p>Os par\u00e2metros de f\u00edsica no 2Do podem ser facilmente ajustados para criar diferentes sensa\u00e7\u00f5es de jogo:</p> <pre><code># Movimento horizontal\nself.max_velocity = 12.0     # Velocidade m\u00e1xima de corrida\nself.acceleration = 1.0      # Qu\u00e3o r\u00e1pido o jogador acelera\nself.deceleration = 8.0      # Qu\u00e3o r\u00e1pido o jogador desacelera\n\n# Movimento vertical\nself.jump_acceleration = -24.0  # For\u00e7a do salto (negativo para cima)\nself.gravity = 35               # For\u00e7a da gravidade\nself.jump_time_max = 0.2        # Dura\u00e7\u00e3o m\u00e1xima do salto\n</code></pre> <p>Modificando estes valores, voc\u00ea pode criar diversas \"sensa\u00e7\u00f5es\" para o jogo: - Aumentar <code>max_velocity</code> e reduzir <code>acceleration</code> cria um personagem que demora para atingir velocidade m\u00e1xima - Aumentar <code>gravity</code> e <code>jump_acceleration</code> cria saltos mais curtos e r\u00e1pidos - Reduzir <code>gravity</code> e <code>jump_acceleration</code> cria saltos mais altos e flutuantes - Aumentar <code>jump_time_max</code> permite ao jogador controlar mais a altura do salto</p>"},{"location":"logica_jogo/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Agora que voc\u00ea compreende a l\u00f3gica central do 2Do, pode explorar:</p> <ul> <li>Sistema de Entrada e Controle - Como personalizar controles e processar entrada</li> <li>Plano de Fundo e Interface - Como o plano de fundo \u00e9 gerenciado</li> <li>Utilit\u00e1rios e Configura\u00e7\u00e3o - Fun\u00e7\u00f5es auxiliares e op\u00e7\u00f5es de configura\u00e7\u00e3o</li> </ul>"},{"location":"plano_fundo/","title":"Plano de Fundo e Parallax Scrolling","text":"<p>Este documento explica como o 2Do gerencia o plano de fundo dos jogos, incluindo como as imagens s\u00e3o carregadas, renderizadas e como o efeito de rolagem paralaxe \u00e9 implementado para criar uma sensa\u00e7\u00e3o de profundidade.</p>"},{"location":"plano_fundo/#visao-geral","title":"Vis\u00e3o Geral","text":"<p>O sistema de plano de fundo do 2Do \u00e9 projetado para:</p> <ol> <li>Carregar imagens de fundo a partir de configura\u00e7\u00f5es</li> <li>Criar uma camada visual que cobre toda a \u00e1rea do jogo</li> <li>Implementar efeito de rolagem (paralaxe) para dar sensa\u00e7\u00e3o de profundidade</li> <li>Permitir f\u00e1cil customiza\u00e7\u00e3o atrav\u00e9s do arquivo de configura\u00e7\u00e3o</li> </ol> <p>A classe principal respons\u00e1vel por essa funcionalidade \u00e9 a <code>Background</code>, localizada no arquivo <code>background.py</code>.</p>"},{"location":"plano_fundo/#a-classe-background","title":"A Classe Background","text":"<pre><code>class Background:\n    def __init__(self, tiled_level, config_parser):\n        self.config_parser = config_parser\n\n        # Carrega a imagem de fundo\n        bg_path = self.config_parser.get(\"background\", \"image\", fallback=\"graphics/Background/Brown.png\")\n        self.tile_bg = pygame.image.load(bg_path).convert_alpha()\n\n        # Limites de blocos para X e Y\n        x_bounds = self.config_parser.get(\"background\", \"x_block_bounds\", fallback=\"12,62\")\n        y_bounds = self.config_parser.get(\"background\", \"y_block_bounds\", fallback=\"10,37\")\n\n        self.x_block_bounds = tuple(map(int, x_bounds.split(\",\")))\n        self.y_block_bounds = tuple(map(int, y_bounds.split(\",\")))\n\n        # Velocidade de rolagem (paralaxe)\n        self.scroll_speed = float(self.config_parser.get(\"background\", \"scroll_speed\", fallback=\"0.6\"))\n\n        # Posi\u00e7\u00e3o inicial da c\u00e2mera\n        self.camera_x = 0\n        self.camera_y = 0\n</code></pre> <p>Esta classe \u00e9 inicializada com dois par\u00e2metros: - <code>tiled_level</code>: O n\u00edvel carregado do arquivo TMX - <code>config_parser</code>: O parser de configura\u00e7\u00e3o que cont\u00e9m as prefer\u00eancias do plano de fundo</p> <p>Durante a inicializa\u00e7\u00e3o, a classe: 1. Carrega a imagem de fundo especificada no arquivo de configura\u00e7\u00e3o 2. Configura os limites de blocos (quanto do fundo ser\u00e1 renderizado) 3. Define a velocidade de rolagem para criar o efeito parallax 4. Inicializa a posi\u00e7\u00e3o da c\u00e2mera em (0,0)</p>"},{"location":"plano_fundo/#carregamento-e-configuracao","title":"Carregamento e Configura\u00e7\u00e3o","text":""},{"location":"plano_fundo/#carregamento-da-imagem","title":"Carregamento da Imagem","text":"<p>O plano de fundo \u00e9 carregado a partir de um arquivo de imagem especificado no <code>config.ini</code>:</p> <pre><code>bg_path = self.config_parser.get(\"background\", \"image\", fallback=\"graphics/Background/Brown.png\")\nself.tile_bg = pygame.image.load(bg_path).convert_alpha()\n</code></pre> <p>O m\u00e9todo <code>convert_alpha()</code> otimiza a imagem para renderiza\u00e7\u00e3o mais r\u00e1pida, preservando o canal de transpar\u00eancia (alpha).</p>"},{"location":"plano_fundo/#limites-de-blocos-e-dimensionamento","title":"Limites de Blocos e Dimensionamento","text":"<p>O plano de fundo \u00e9 constru\u00eddo repetindo (ou \"tilando\") uma imagem base. Os par\u00e2metros <code>x_block_bounds</code> e <code>y_block_bounds</code> definem a \u00e1rea de cobertura:</p> <pre><code>x_bounds = self.config_parser.get(\"background\", \"x_block_bounds\", fallback=\"12,62\")\ny_bounds = self.config_parser.get(\"background\", \"y_block_bounds\", fallback=\"10,37\")\n\nself.x_block_bounds = tuple(map(int, x_bounds.split(\",\")))\nself.y_block_bounds = tuple(map(int, y_bounds.split(\",\")))\n</code></pre> <p>Por exemplo, com <code>x_block_bounds = 12,62</code> e <code>y_block_bounds = 10,37</code>: - O plano de fundo ter\u00e1 50 blocos de largura (62-12) - O plano de fundo ter\u00e1 27 blocos de altura (37-10)</p> <p>Por que esses valores s\u00e3o importantes?</p> <p>Imagine que cada bloco de fundo tenha dimens\u00f5es de 64x64 pixels. Com os valores acima: - A largura total do fundo seria 50 \u00d7 64 = 3200 pixels - A altura total do fundo seria 27 \u00d7 64 = 1728 pixels</p> <p>Esses valores devem ser grandes o suficiente para cobrir a \u00e1rea vis\u00edvel do jogo, mesmo durante a rolagem.</p>"},{"location":"plano_fundo/#renderizacao-do-plano-de-fundo","title":"Renderiza\u00e7\u00e3o do Plano de Fundo","text":"<p>A renderiza\u00e7\u00e3o do plano de fundo acontece no m\u00e9todo <code>render</code>:</p> <pre><code>def render(self, screen, block_size):\n    # Calcula o tamanho total do plano de fundo\n    bg_width = (self.x_block_bounds[1] - self.x_block_bounds[0]) * self.tile_bg.get_width()\n    bg_height = (self.y_block_bounds[1] - self.y_block_bounds[0]) * self.tile_bg.get_height()\n\n    # Calcula quantos blocos s\u00e3o vis\u00edveis na tela\n    screen_width, screen_height = screen.get_size()\n    visible_width = screen_width / block_size[0]\n    visible_height = screen_height / block_size[1]\n\n    # Calcula a posi\u00e7\u00e3o da c\u00e2mera aplicando o efeito parallax\n    camera_x = self.camera_x * self.scroll_speed\n    camera_y = self.camera_y * self.scroll_speed\n\n    # Calcula a posi\u00e7\u00e3o de in\u00edcio da renderiza\u00e7\u00e3o\n    start_x = int(camera_x) % self.tile_bg.get_width()\n    start_y = int(camera_y) % self.tile_bg.get_height()\n\n    # Renderiza os blocos vis\u00edveis\n    for y in range(-1, int(visible_height) + 2):\n        for x in range(-1, int(visible_width) + 2):\n            # Posi\u00e7\u00e3o do bloco na tela\n            draw_x = (x * self.tile_bg.get_width()) - start_x\n            draw_y = (y * self.tile_bg.get_height()) - start_y\n\n            # Desenha o bloco\n            screen.blit(self.tile_bg, (draw_x, draw_y))\n</code></pre> <p>Este m\u00e9todo implementa um sistema de renderiza\u00e7\u00e3o eficiente:</p> <ol> <li>C\u00e1lculo de dimens\u00f5es:</li> <li>Determina o tamanho total do plano de fundo com base nos limites de blocos</li> <li> <p>Calcula quantos blocos s\u00e3o vis\u00edveis na tela atual</p> </li> <li> <p>Posicionamento da c\u00e2mera com parallax:</p> </li> <li>Aplica a velocidade de rolagem \u00e0 posi\u00e7\u00e3o da c\u00e2mera para criar o efeito paralaxe</li> <li> <p>O efeito paralaxe faz com que o fundo se mova mais lentamente que os elementos do jogo</p> </li> <li> <p>Tiling eficiente:</p> </li> <li>Calcula a posi\u00e7\u00e3o inicial de desenho com base na posi\u00e7\u00e3o da c\u00e2mera</li> <li>Renderiza apenas os blocos vis\u00edveis na tela, mais uma margem de seguran\u00e7a (-1 e +2)</li> <li> <p>Usa a opera\u00e7\u00e3o de m\u00f3dulo (%) para criar um padr\u00e3o de repeti\u00e7\u00e3o infinita</p> </li> <li> <p>Desenho dos blocos:</p> </li> <li>Posiciona cada bloco no local correto da tela</li> <li>Usa <code>screen.blit()</code> para desenhar a imagem na superf\u00edcie da tela</li> </ol> <p>A imagem abaixo ilustra como funciona a renderiza\u00e7\u00e3o do plano de fundo por tiling:</p> <pre><code>+---+---+---+---+---+  \n| 1 | 2 | 3 | 4 | 5 |  \u2192 Blocos de imagem repetidos horizontalmente\n+---+---+---+---+---+\n| 6 | 7 | 8 | 9 |10 |\n+---+---+---+---+---+  \u2192 \u00c1rea vis\u00edvel da tela\n|11 |12 |13 |14 |15 |     (pode mostrar apenas uma parte do padr\u00e3o)\n+---+---+---+---+---+\n|16 |17 |18 |19 |20 |\n+---+---+---+---+---+\n</code></pre>"},{"location":"plano_fundo/#efeito-de-rolagem-paralaxe","title":"Efeito de Rolagem (Paralaxe)","text":"<p>O efeito de parallax \u00e9 o que d\u00e1 profundidade ao jogo, fazendo com que o plano de fundo se mova mais lentamente que os elementos em primeiro plano. Isto simula o fen\u00f4meno do mundo real onde objetos distantes parecem se mover mais devagar quando nos deslocamos.</p>"},{"location":"plano_fundo/#atualizacao-da-posicao-da-camera","title":"Atualiza\u00e7\u00e3o da Posi\u00e7\u00e3o da C\u00e2mera","text":"<pre><code>def update(self, player_x, player_y):\n    # Atualiza a posi\u00e7\u00e3o da c\u00e2mera com base na posi\u00e7\u00e3o do jogador\n    self.camera_x = player_x - (self.x_block_bounds[1] - self.x_block_bounds[0]) / 2\n    self.camera_y = player_y - (self.y_block_bounds[1] - self.y_block_bounds[0]) / 2\n\n    # Limita a c\u00e2mera aos limites do mundo do jogo\n    self.camera_x = max(self.x_block_bounds[0], min(self.camera_x, self.x_block_bounds[1]))\n    self.camera_y = max(self.y_block_bounds[0], min(self.camera_y, self.y_block_bounds[1]))\n</code></pre> <p>O m\u00e9todo <code>update</code> \u00e9 chamado a cada frame do jogo e realiza estas opera\u00e7\u00f5es:</p> <ol> <li>Centraliza a c\u00e2mera no jogador:</li> <li>Calcula a posi\u00e7\u00e3o ideal da c\u00e2mera para manter o jogador no centro da tela</li> <li> <p>Subtrai metade da largura/altura vis\u00edvel para centralizar</p> </li> <li> <p>Limita os limites da c\u00e2mera:</p> </li> <li>Impede que a c\u00e2mera se mova al\u00e9m dos limites do mundo do jogo</li> <li>Usa <code>max</code> e <code>min</code> para restringir os valores dentro dos limites definidos</li> </ol>"},{"location":"plano_fundo/#aplicacao-do-efeito-paralaxe","title":"Aplica\u00e7\u00e3o do Efeito Paralaxe","text":"<p>O efeito paralaxe propriamente dito \u00e9 aplicado durante a renderiza\u00e7\u00e3o:</p> <pre><code># No m\u00e9todo render\ncamera_x = self.camera_x * self.scroll_speed\ncamera_y = self.camera_y * self.scroll_speed\n</code></pre> <p>O <code>scroll_speed</code> controla qu\u00e3o rapidamente o fundo se move em rela\u00e7\u00e3o aos elementos do jogo:</p> <ul> <li><code>scroll_speed = 1.0</code>: O fundo se move na mesma velocidade que o jogador (sem efeito parallax)</li> <li><code>scroll_speed = 0.5</code>: O fundo se move na metade da velocidade do jogador (paralaxe moderado)</li> <li><code>scroll_speed = 0.2</code>: O fundo se move muito mais lentamente que o jogador (paralaxe intenso)</li> </ul> <p>Quanto menor o valor, mais distante o fundo parece estar, criando uma impress\u00e3o de profundidade maior.</p>"},{"location":"plano_fundo/#como-o-paralaxe-cria-profundidade","title":"Como o Paralaxe Cria Profundidade","text":"<p>Para entender como o paralaxe cria profundidade, imagine um cen\u00e1rio com tr\u00eas camadas:</p> <ol> <li>Jogador e plataformas - Movem-se 1:1 com a c\u00e2mera (primeiro plano)</li> <li>Montanhas - Movem-se a 0.6x da velocidade da c\u00e2mera (plano m\u00e9dio)</li> <li>C\u00e9u estrelado - Move-se a 0.2x da velocidade da c\u00e2mera (plano de fundo distante)</li> </ol> <p>Quando o jogador se move 100 pixels para a direita: - O jogador e as plataformas se movem 100 pixels na tela - As montanhas se movem apenas 60 pixels (0.6 \u00d7 100) - O c\u00e9u estrelado se move apenas 20 pixels (0.2 \u00d7 100)</p> <p>Este efeito imita o que vemos no mundo real: quando nos movemos, objetos pr\u00f3ximos parecem passar mais rapidamente que objetos distantes. Dirigindo em uma estrada, as \u00e1rvores pr\u00f3ximas passam rapidamente, enquanto as montanhas distantes parecem se mover muito lentamente.</p>"},{"location":"plano_fundo/#customizacao-do-plano-de-fundo","title":"Customiza\u00e7\u00e3o do Plano de Fundo","text":"<p>O sistema de plano de fundo do 2Do \u00e9 altamente customiz\u00e1vel atrav\u00e9s do arquivo <code>config.ini</code>:</p> <pre><code>[background]\nimage = graphics/Background/Brown.png\nx_block_bounds = 12,62\ny_block_bounds = 10,37\nscroll_speed = 0.6\n</code></pre> <p>Voc\u00ea pode modificar:</p> <ol> <li><code>image</code>: Caminho para qualquer imagem PNG compat\u00edvel</li> <li>Recomenda-se usar imagens que possam ser repetidas naturalmente (tilable)</li> <li> <p>Imagens pequenas (64x64 ou 128x128) funcionam bem para padr\u00f5es repetitivos</p> </li> <li> <p><code>x_block_bounds</code> e <code>y_block_bounds</code>: Define o tamanho do mundo do jogo</p> </li> <li>Valores maiores criam mundos mais amplos</li> <li> <p>Deve ser grande o suficiente para acomodar todos os elementos do jogo</p> </li> <li> <p><code>scroll_speed</code>: Controla o efeito de parallax</p> </li> <li>Valores entre 0.3 e 0.8 geralmente funcionam bem</li> <li>Valores mais baixos criam uma sensa\u00e7\u00e3o de maior profundidade</li> </ol>"},{"location":"plano_fundo/#dicas-para-criar-planos-de-fundo-eficazes","title":"Dicas para Criar Planos de Fundo Eficazes","text":"<ol> <li>Use imagens tilable: Imagens que se repetem naturalmente sem bordas vis\u00edveis</li> <li>Texturas como grama, terra, c\u00e9u, tijolos funcionam bem</li> <li> <p>Evite elementos \u00fanicos que criariam repeti\u00e7\u00e3o \u00f3bvia</p> </li> <li> <p>Considere m\u00faltiplas camadas: Para jogos mais complexos, pode-se implementar v\u00e1rias camadas</p> </li> <li>C\u00e9u (mais distante, scroll_speed baixo)</li> <li>Montanhas ou nuvens (dist\u00e2ncia m\u00e9dia, scroll_speed m\u00e9dio)</li> <li> <p>\u00c1rvores ou arbustos (mais pr\u00f3ximo, scroll_speed mais alto)</p> </li> <li> <p>Otimize o desempenho:</p> </li> <li>Use imagens de tamanho razo\u00e1vel (evite texturas gigantes)</li> <li>Certifique-se de que sua imagem use <code>convert_alpha()</code> para melhor desempenho</li> </ol>"},{"location":"plano_fundo/#exemplo-criando-um-efeito-de-ceu-estrelado","title":"Exemplo: Criando um Efeito de C\u00e9u Estrelado","text":"<pre><code>[background]\nimage = graphics/Background/NightSky.png\nx_block_bounds = 10,70\ny_block_bounds = 5,45\nscroll_speed = 0.2\n</code></pre> <p>Com este exemplo: - Uma imagem de c\u00e9u estrelado ser\u00e1 usada como fundo - O mundo do jogo ser\u00e1 grande (60 blocos de largura por 40 de altura) - O efeito parallax ser\u00e1 intenso (0.2), fazendo com que o c\u00e9u pare\u00e7a muito distante</p>"},{"location":"plano_fundo/#conclusao","title":"Conclus\u00e3o","text":"<p>O sistema de plano de fundo do 2Do oferece uma solu\u00e7\u00e3o simples mas eficaz para criar cen\u00e1rios visualmente interessantes com efeito de profundidade. Atrav\u00e9s da t\u00e9cnica de tiling e do efeito paralaxe, o motor consegue criar a ilus\u00e3o de um mundo maior e mais profundo, mesmo com recursos gr\u00e1ficos limitados.</p> <p>A facilidade de configura\u00e7\u00e3o permite que desenvolvedores personalizem rapidamente a apar\u00eancia de seus jogos sem precisar modificar o c\u00f3digo-fonte.</p>"},{"location":"plano_fundo/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Agora que voc\u00ea entende como funciona o sistema de plano de fundo, pode explorar:</p> <ul> <li>Entidades e Objetos do Jogo - Como objetos s\u00e3o posicionados neste mundo</li> <li>Configura\u00e7\u00e3o e Setup - Mais op\u00e7\u00f5es de configura\u00e7\u00e3o para personalizar seu jogo</li> <li>Sistema de Gerenciamento de Recursos - Como outros recursos gr\u00e1ficos s\u00e3o gerenciados</li> </ul>"},{"location":"referencias/","title":"Refer\u00eancias e Pr\u00f3ximos Passos","text":"<p>Este documento fornece refer\u00eancias importantes para aprofundar seu conhecimento sobre as tecnologias utilizadas no 2Do, al\u00e9m de apontar caminhos para futuras melhorias e expans\u00f5es do motor.</p>"},{"location":"referencias/#documentacao-oficial","title":"Documenta\u00e7\u00e3o Oficial","text":"<p>Para explorar mais profundamente as tecnologias que formam a base do 2Do, recomendamos consultar a documenta\u00e7\u00e3o oficial:</p>"},{"location":"referencias/#pygame","title":"Pygame","text":"<p>O Pygame \u00e9 a biblioteca central usada pelo 2Do para criar jogos 2D em Python. Sua documenta\u00e7\u00e3o oficial cont\u00e9m tutoriais, refer\u00eancias de API e exemplos que podem ajudar a entender melhor o funcionamento interno do 2Do.</p> <ul> <li>Documenta\u00e7\u00e3o Oficial do Pygame: https://www.pygame.org/docs/</li> <li>Tutoriais de Pygame: https://www.pygame.org/wiki/tutorials</li> <li>Exemplos de Pygame: https://www.pygame.org/docs/ref/examples.html</li> </ul> <p>Alguns m\u00f3dulos do Pygame especialmente relevantes para o 2Do:</p> <ul> <li>pygame.sprite: https://www.pygame.org/docs/ref/sprite.html - Base para sistemas de entidades</li> <li>pygame.Surface: https://www.pygame.org/docs/ref/surface.html - Manipula\u00e7\u00e3o de imagens e renderiza\u00e7\u00e3o</li> <li>pygame.Rect: https://www.pygame.org/docs/ref/rect.html - Colis\u00f5es e posicionamento</li> </ul>"},{"location":"referencias/#pytmx","title":"PyTMX","text":"<p>O PyTMX \u00e9 usado pelo 2Do para carregar e processar mapas criados com o Tiled Map Editor, permitindo a cria\u00e7\u00e3o visual de n\u00edveis.</p> <ul> <li>Documenta\u00e7\u00e3o Oficial do PyTMX: https://pytmx.readthedocs.io/en/latest/</li> <li>Reposit\u00f3rio PyTMX no GitHub: https://github.com/bitcraft/pytmx</li> </ul>"},{"location":"referencias/#tiled-map-editor","title":"Tiled Map Editor","text":"<p>Embora n\u00e3o seja uma biblioteca Python, o Tiled \u00e9 uma ferramenta essencial para criar n\u00edveis para jogos que utilizam o 2Do.</p> <ul> <li>Site Oficial do Tiled: https://www.mapeditor.org/</li> <li>Documenta\u00e7\u00e3o do Tiled: https://doc.mapeditor.org/en/stable/</li> <li>Manual do Tiled: https://doc.mapeditor.org/en/stable/manual/introduction/</li> </ul>"},{"location":"referencias/#codigo-fonte-e-repositorio","title":"C\u00f3digo Fonte e Reposit\u00f3rio","text":"<p>O c\u00f3digo fonte completo do 2Do est\u00e1 dispon\u00edvel no GitHub, permitindo que voc\u00ea explore a implementa\u00e7\u00e3o, fa\u00e7a suas pr\u00f3prias modifica\u00e7\u00f5es ou contribua para o projeto.</p> <ul> <li>Reposit\u00f3rio do 2Do no GitHub: https://github.com/lucaslattari/2Do_game_engine</li> </ul>"},{"location":"referencias/#proximos-passos-e-melhorias-sugeridas","title":"Pr\u00f3ximos Passos e Melhorias Sugeridas","text":"<p>O 2Do \u00e9 um motor em evolu\u00e7\u00e3o, e existem v\u00e1rias \u00e1reas onde melhorias e expans\u00f5es podem ser implementadas. Abaixo est\u00e3o algumas sugest\u00f5es para desenvolvedores interessados em contribuir ou expandir o motor para seus pr\u00f3prios projetos.</p>"},{"location":"referencias/#sistema-de-audio","title":"Sistema de \u00c1udio","text":"<p>O sistema de \u00e1udio atual do 2Do est\u00e1 incompleto e poderia ser expandido para incluir:</p> <ol> <li> <p>Gerenciamento de Efeitos Sonoros</p> </li> <li> <p>Reprodu\u00e7\u00e3o de M\u00fasica de Fundo:</p> </li> <li>Implementar transi\u00e7\u00f5es suaves entre faixas</li> <li> <p>Permitir controle detalhado (pausar, retomar, fade in/out)</p> </li> <li> <p>Mixagem Din\u00e2mica:</p> </li> <li>Ajustar volumes com base na dist\u00e2ncia de objetos</li> <li>Implementar sons posicionais (esquerda/direita)</li> </ol>"},{"location":"referencias/#sistema-de-particulas","title":"Sistema de Part\u00edculas","text":"<p>Um sistema de part\u00edculas permitiria efeitos visuais mais ricos, como: * Poeira quando o personagem corre ou pousa * Efeitos de explos\u00e3o * Brilhos e outros elementos decorativos</p>"},{"location":"referencias/#melhorias-na-fisica","title":"Melhorias na F\u00edsica","text":"<p>O sistema de f\u00edsica atual poderia ser expandido para incluir:</p> <ol> <li>F\u00edsica mais Realista:</li> <li>Implementar amortecimento de movimento</li> <li>Adicionar atrito vari\u00e1vel para diferentes superf\u00edcies</li> <li> <p>Melhorar a simula\u00e7\u00e3o de gravidade</p> </li> <li> <p>Tipos Adicionais de Movimento:</p> </li> <li>Implementar movimentos em arco</li> <li>Adicionar impulsos e for\u00e7as</li> <li> <p>Suportar ventos e correntes de ar</p> </li> <li> <p>Sistema de Colis\u00e3o Aprimorado:</p> </li> <li>Detec\u00e7\u00e3o de colis\u00e3o com formas complexas (al\u00e9m de ret\u00e2ngulos)</li> <li>Melhor resposta \u00e0 colis\u00e3o com \u00e2ngulos e superf\u00edcies inclinadas</li> <li>Otimizar detec\u00e7\u00e3o para melhor desempenho</li> </ol>"},{"location":"referencias/#ferramentas-de-desenvolvimento","title":"Ferramentas de Desenvolvimento","text":"<p>Para facilitar o desenvolvimento de jogos com o 2Do, poderiam ser criadas:</p> <ol> <li>Editor de N\u00edveis Integrado:</li> <li>Interface visual para criar e testar n\u00edveis dentro do motor</li> <li> <p>Extens\u00e3o da integra\u00e7\u00e3o com o Tiled</p> </li> <li> <p>Console de Depura\u00e7\u00e3o:</p> </li> <li>Ferramenta para monitorar e ajustar vari\u00e1veis em tempo real</li> <li> <p>Visualiza\u00e7\u00e3o de colis\u00f5es e outros elementos invis\u00edveis</p> </li> <li> <p>Profiler Visual:</p> </li> <li>Ferramenta para identificar gargalos de desempenho</li> <li>Visualiza\u00e7\u00e3o da utiliza\u00e7\u00e3o de recursos</li> </ol>"},{"location":"referencias/#suporte-a-multiplos-formatos","title":"Suporte a M\u00faltiplos Formatos","text":"<p>Para aumentar a flexibilidade do motor, poderia ser adicionado suporte a:</p> <ol> <li>Formatos Adicionais de Mapas:</li> <li>Suporte a outros formatos al\u00e9m do TMX</li> <li> <p>Possibilidade de criar mapas procedurais</p> </li> <li> <p>Formatos de Imagem Adicionais:</p> </li> <li>Melhor suporte para anima\u00e7\u00f5es (spritesheets, GIFs)</li> <li> <p>Suporte a formatos otimizados</p> </li> <li> <p>Frameworks Alternativos:</p> </li> <li>Op\u00e7\u00e3o de usar SDL ou outras bibliotecas como alternativa ao Pygame</li> <li>Adaptadores para diferentes sistemas de renderiza\u00e7\u00e3o</li> </ol>"},{"location":"referencias/#componentes-de-interface-do-usuario","title":"Componentes de Interface do Usu\u00e1rio","text":"<p>O 2Do poderia incluir um sistema de UI (Interface do Usu\u00e1rio) para:</p> <ol> <li>Menus e Telas:</li> <li>Sistema para criar menus, telas de t\u00edtulo e de game over</li> <li> <p>Transi\u00e7\u00f5es entre telas</p> </li> <li> <p>HUD (Heads-Up Display):</p> </li> <li>Componentes para mostrar informa\u00e7\u00f5es como vida, pontua\u00e7\u00e3o, itens</li> <li> <p>Minimapas e outros elementos informativos</p> </li> <li> <p>Di\u00e1logos e Textos:</p> </li> <li>Sistema para exibir di\u00e1logos e textos narrativos</li> <li>Suporte a m\u00faltiplos idiomas</li> </ol>"},{"location":"referencias/#expansao-do-sistema-de-entidades","title":"Expans\u00e3o do Sistema de Entidades","text":"<p>O sistema atual de entidades poderia ser expandido para:</p> <ol> <li>Arquitetura ECS (Entity-Component-System):</li> <li>Maior modularidade e reutiliza\u00e7\u00e3o</li> <li> <p>Melhor organiza\u00e7\u00e3o para jogos complexos</p> </li> <li> <p>Gerenciador de Estados mais Avan\u00e7ado:</p> </li> <li>Transi\u00e7\u00f5es mais suaves entre estados</li> <li> <p>M\u00e1quinas de estado hier\u00e1rquicas</p> </li> <li> <p>IA mais Complexa:</p> </li> <li>Comportamentos mais sofisticados para entidades n\u00e3o jog\u00e1veis</li> <li>Sistemas de navega\u00e7\u00e3o e pathfinding</li> </ol>"},{"location":"referencias/#documentacao-e-tutoriais","title":"Documenta\u00e7\u00e3o e Tutoriais","text":"<p>A documenta\u00e7\u00e3o poderia ser expandida com:</p> <ol> <li>Guias Detalhados:</li> <li>Tutoriais passo a passo para diferentes aspectos do motor</li> <li> <p>Exemplos de implementa\u00e7\u00e3o de mec\u00e2nicas comuns</p> </li> <li> <p>Documenta\u00e7\u00e3o de API Interativa:</p> </li> <li>Refer\u00eancia completa e naveg\u00e1vel de todas as classes e fun\u00e7\u00f5es</li> <li> <p>Exemplos de c\u00f3digo para cada componente principal</p> </li> <li> <p>Projetos de Exemplo:</p> </li> <li>Jogos completos demonstrando diferentes g\u00eaneros e t\u00e9cnicas</li> <li>Estudos de caso explicando decis\u00f5es de design</li> </ol>"},{"location":"referencias/#ideias-para-jogos-com-o-2do","title":"Ideias para Jogos com o 2Do","text":"<p>Para inspirar sua criatividade, aqui est\u00e3o algumas ideias de jogos que poderiam ser desenvolvidos com o motor 2Do:</p> <ol> <li>Plataforma de Aventura:</li> <li>Jogo estilo Mario com n\u00edveis coloridos e mec\u00e2nicas de pulo</li> <li> <p>Foco em explora\u00e7\u00e3o e coleta de itens</p> </li> <li> <p>Runner com Obst\u00e1culos:</p> </li> <li>Jogo de corrida autom\u00e1tica onde o jogador deve pular e esquivar</li> <li> <p>Mec\u00e2nicas simples, mas desafiadoras</p> </li> <li> <p>Quebra-cabe\u00e7as de Plataforma:</p> </li> <li>Jogo focado em resolver enigmas utilizando gravidade e movimento</li> <li> <p>Inspirado em jogos como \"Thomas Was Alone\" ou \"Braid\"</p> </li> <li> <p>Metroidvania Simples:</p> </li> <li>Mundo interconectado com \u00e1reas desbloque\u00e1veis</li> <li>Foco em melhorias de personagem e novas habilidades</li> </ol>"},{"location":"referencias/#agradecimentos","title":"Agradecimentos","text":"<p>O 2Do foi criado e \u00e9 mantido por Lucas Lattari, com contribui\u00e7\u00f5es da comunidade. Se voc\u00ea encontrar este projeto \u00fatil, considere contribuir com c\u00f3digo, documenta\u00e7\u00e3o ou simplesmente compartilhando seus projetos criados com o motor.</p>"},{"location":"utils/","title":"Utilit\u00e1rios e Fun\u00e7\u00f5es Auxiliares","text":"<p>Este documento descreve as fun\u00e7\u00f5es utilit\u00e1rias que d\u00e3o suporte ao 2Do, encontradas no arquivo <code>utils.py</code>. Estas fun\u00e7\u00f5es realizam tarefas auxiliares que, embora n\u00e3o fa\u00e7am parte da l\u00f3gica central do jogo, s\u00e3o essenciais para seu funcionamento adequado.</p>"},{"location":"utils/#visao-geral","title":"Vis\u00e3o Geral","text":"<p>As fun\u00e7\u00f5es utilit\u00e1rias no 2Do servem para:</p> <ol> <li>Carregar e processar configura\u00e7\u00f5es</li> <li>Fornecer ferramentas de depura\u00e7\u00e3o e monitoramento de desempenho</li> <li>Simplificar opera\u00e7\u00f5es comuns e repetitivas</li> <li>Aumentar a legibilidade do c\u00f3digo principal</li> </ol> <p>O arquivo <code>utils.py</code> centraliza estas fun\u00e7\u00f5es, mantendo o restante do c\u00f3digo limpo e focado em suas responsabilidades espec\u00edficas.</p>"},{"location":"utils/#carregamento-de-configuracoes","title":"Carregamento de Configura\u00e7\u00f5es","text":""},{"location":"utils/#a-funcao-read_config_file","title":"A Fun\u00e7\u00e3o read_config_file","text":"<pre><code>def read_config_file(config_path):\n    \"\"\"\n    Carrega configura\u00e7\u00f5es a partir de um arquivo .ini\n\n    Args:\n        config_path (str): Caminho para o arquivo de configura\u00e7\u00e3o\n\n    Returns:\n        configparser.ConfigParser: Parser com as configura\u00e7\u00f5es carregadas\n    \"\"\"\n    config_parser = configparser.ConfigParser()\n\n    if os.path.exists(config_path):\n        try:\n            config_parser.read(config_path)\n            print(f\"Configura\u00e7\u00f5es carregadas de {config_path}\")\n        except Exception as e:\n            print(f\"Erro ao ler o arquivo de configura\u00e7\u00e3o: {e}\")\n            print(\"Usando configura\u00e7\u00f5es padr\u00e3o\")\n    else:\n        print(f\"Arquivo de configura\u00e7\u00e3o {config_path} n\u00e3o encontrado\")\n        print(\"Usando configura\u00e7\u00f5es padr\u00e3o\")\n\n    return config_parser\n</code></pre> <p>Esta fun\u00e7\u00e3o \u00e9 respons\u00e1vel por carregar o arquivo de configura\u00e7\u00e3o que personaliza diversos aspectos do 2Do, como gr\u00e1ficos, \u00e1udio e comportamento do plano de fundo.</p>"},{"location":"utils/#como-funciona","title":"Como Funciona","text":"<ol> <li>Cria\u00e7\u00e3o do parser: Inicializa um objeto <code>ConfigParser</code> do m\u00f3dulo <code>configparser</code> padr\u00e3o do Python</li> <li>Verifica\u00e7\u00e3o de exist\u00eancia: Verifica se o arquivo de configura\u00e7\u00e3o existe no caminho especificado</li> <li>Tentativa de leitura: Se o arquivo existir, tenta carreg\u00e1-lo</li> <li>Tratamento de erros: Caso haja problemas ao ler o arquivo, informa o usu\u00e1rio e usa configura\u00e7\u00f5es padr\u00e3o</li> <li>Retorno do parser: Retorna o objeto parser que cont\u00e9m as configura\u00e7\u00f5es carregadas</li> </ol>"},{"location":"utils/#uso-no-codigo-principal","title":"Uso no C\u00f3digo Principal","text":"<p>No arquivo <code>main.py</code>, esta fun\u00e7\u00e3o \u00e9 chamada no in\u00edcio do programa:</p> <pre><code>def main():\n    pygame.init()\n    pygame.font.init()\n\n    config_parser = read_config_file(\"config.ini\")\n\n    game = Game(config_parser=config_parser)\n    game.load_screen()\n    game.load_level(\"maps/level1.tmx\")\n\n    # ... resto do c\u00f3digo\n</code></pre> <p>O <code>config_parser</code> retornado \u00e9 ent\u00e3o passado para a classe <code>Game</code>, que usa as configura\u00e7\u00f5es para inicializar diversos componentes, como a tela, o plano de fundo e as entidades.</p>"},{"location":"utils/#estrutura-do-arquivo-de-configuracao","title":"Estrutura do Arquivo de Configura\u00e7\u00e3o","text":"<p>O arquivo <code>config.ini</code> geralmente cont\u00e9m se\u00e7\u00f5es como:</p> <pre><code>[graphics]\nresolution = 1280x720\nfullscreen = no\n\n[audio]\nvolume = 80\n\n[background]\nimage = graphics/Background/Brown.png\nx_block_bounds = 12,62\ny_block_bounds = 10,37\nscroll_speed = 0.6\n</code></pre> <p>Cada se\u00e7\u00e3o agrupa configura\u00e7\u00f5es relacionadas, facilitando a organiza\u00e7\u00e3o e leitura.</p>"},{"location":"utils/#valores-padrao-e-fallbacks","title":"Valores Padr\u00e3o e Fallbacks","text":"<p>Quando as configura\u00e7\u00f5es s\u00e3o utilizadas em outras partes do c\u00f3digo, valores padr\u00e3o (fallbacks) s\u00e3o especificados para garantir que o jogo funcione mesmo que certas configura\u00e7\u00f5es estejam ausentes:</p> <pre><code># Exemplo de uso com fallback em game.py\nresolution_str = self.config_parser.get(\"graphics\", \"resolution\", fallback=\"1280x720\")\nself.width, self.height = map(int, resolution_str.split(\"x\"))\n</code></pre> <p>Isto torna o sistema robusto, pois mesmo que o arquivo de configura\u00e7\u00e3o esteja incompleto ou ausente, o jogo ainda ter\u00e1 valores razo\u00e1veis para trabalhar.</p>"},{"location":"utils/#monitoramento-de-desempenho","title":"Monitoramento de Desempenho","text":""},{"location":"utils/#a-funcao-render_fps","title":"A Fun\u00e7\u00e3o render_fps","text":"<pre><code>def render_fps(fps, screen, font, color=(255, 255, 255), position=(10, 10)):\n    \"\"\"\n    Renderiza a taxa de quadros atual na tela\n\n    Args:\n        fps (float): Taxa de quadros atual\n        screen (pygame.Surface): Superf\u00edcie onde o texto ser\u00e1 renderizado\n        font (pygame.font.Font): Fonte a ser usada\n        color (tuple): Cor do texto (R, G, B)\n        position (tuple): Posi\u00e7\u00e3o do texto na tela (x, y)\n    \"\"\"\n    fps_text = font.render(f\"FPS: {int(fps)}\", True, color)\n    screen.blit(fps_text, position)\n</code></pre> <p>Esta fun\u00e7\u00e3o exibe a taxa de quadros por segundo (FPS) atual na tela, uma informa\u00e7\u00e3o crucial para monitorar o desempenho do jogo durante o desenvolvimento.</p>"},{"location":"utils/#como-funciona_1","title":"Como Funciona","text":"<ol> <li>Renderiza\u00e7\u00e3o de texto: Converte o valor de FPS em texto usando a fonte fornecida</li> <li>Desenho na tela: Desenha o texto renderizado na posi\u00e7\u00e3o especificada</li> </ol>"},{"location":"utils/#uso-no-ciclo-principal","title":"Uso no Ciclo Principal","text":"<p>No arquivo <code>main.py</code>, esta fun\u00e7\u00e3o \u00e9 chamada a cada itera\u00e7\u00e3o do ciclo principal:</p> <pre><code>def main():\n    # ... c\u00f3digo anterior\n\n    # Inicializa\u00e7\u00e3o da fonte para o FPS\n    font = pygame.font.SysFont(\"Arial\", 24)\n\n    while running:\n        delta_time = clock.tick(60) / 1000.0\n\n        # ... atualiza\u00e7\u00e3o e renderiza\u00e7\u00e3o do jogo\n\n        render_fps(clock.get_fps(), game.screen, font)\n\n        pygame.display.update()\n</code></pre>"},{"location":"utils/#customizacao-da-exibicao","title":"Customiza\u00e7\u00e3o da Exibi\u00e7\u00e3o","text":"<p>A fun\u00e7\u00e3o aceita par\u00e2metros para personalizar a apar\u00eancia do contador de FPS:</p> <ul> <li>color: Define a cor do texto (padr\u00e3o: branco)</li> <li>position: Define a posi\u00e7\u00e3o do texto na tela (padr\u00e3o: canto superior esquerdo)</li> </ul>"},{"location":"utils/#outras-funcoes-utilitarias-comuns","title":"Outras Fun\u00e7\u00f5es Utilit\u00e1rias Comuns","text":"<p>Al\u00e9m das fun\u00e7\u00f5es principais descritas acima, o arquivo <code>utils.py</code> cont\u00e9m outras fun\u00e7\u00f5es auxiliares que simplificam tarefas comuns em jogos 2D.</p>"},{"location":"utils/#calculo-de-distancia","title":"C\u00e1lculo de Dist\u00e2ncia","text":"<pre><code>def distance(point1, point2):\n    \"\"\"\n    Calcula a dist\u00e2ncia euclidiana entre dois pontos\n\n    Args:\n        point1 (tuple): Coordenadas (x, y) do primeiro ponto\n        point2 (tuple): Coordenadas (x, y) do segundo ponto\n\n    Returns:\n        float: Dist\u00e2ncia entre os pontos\n    \"\"\"\n    return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n</code></pre> <p>Esta fun\u00e7\u00e3o calcula a dist\u00e2ncia entre dois pontos no plano, \u00fatil para verificar proximidade entre entidades.</p>"},{"location":"utils/#conversao-de-coordenadas","title":"Convers\u00e3o de Coordenadas","text":"<pre><code>def world_to_screen(x, y, camera_x, camera_y, block_size):\n    \"\"\"\n    Converte coordenadas do mundo para coordenadas da tela\n\n    Args:\n        x (float): Coordenada X no mundo\n        y (float): Coordenada Y no mundo\n        camera_x (float): Posi\u00e7\u00e3o X da c\u00e2mera\n        camera_y (float): Posi\u00e7\u00e3o Y da c\u00e2mera\n        block_size (tuple): Tamanho do bloco (width, height)\n\n    Returns:\n        tuple: Coordenadas (x, y) na tela\n    \"\"\"\n    screen_x = (x - camera_x) * block_size[0]\n    screen_y = (y - camera_y) * block_size[1]\n    return (screen_x, screen_y)\n</code></pre> <p>Esta fun\u00e7\u00e3o converte coordenadas do mundo do jogo para coordenadas da tela, essencial para renderiza\u00e7\u00e3o correta.</p>"},{"location":"utils/#conversao-de-tempo","title":"Convers\u00e3o de Tempo","text":"<pre><code>def format_time(milliseconds):\n    \"\"\"\n    Formata um valor em milissegundos para um formato leg\u00edvel (MM:SS.mmm)\n\n    Args:\n        milliseconds (int): Tempo em milissegundos\n\n    Returns:\n        str: Tempo formatado\n    \"\"\"\n    seconds = milliseconds / 1000\n    minutes = int(seconds / 60)\n    seconds = seconds % 60\n    return f\"{minutes:02d}:{seconds:05.2f}\"\n</code></pre> <p>Esta fun\u00e7\u00e3o converte um tempo em milissegundos para um formato leg\u00edvel de minutos e segundos, \u00fatil para temporizadores de jogo.</p>"},{"location":"utils/#integracao-com-o-restante-do-motor","title":"Integra\u00e7\u00e3o com o Restante do Motor","text":"<p>As fun\u00e7\u00f5es utilit\u00e1rias s\u00e3o integradas ao restante do motor de formas diversas:</p>"},{"location":"utils/#no-arquivo-principal-mainpy","title":"No Arquivo Principal (main.py)","text":"<pre><code>def main():\n    # Inicializa\u00e7\u00e3o\n    pygame.init()\n    pygame.font.init()\n\n    # Carrega configura\u00e7\u00f5es\n    config_parser = read_config_file(\"config.ini\")\n\n    # Inicializa o jogo\n    game = Game(config_parser=config_parser)\n    game.load_screen()\n    game.load_level(\"maps/level1.tmx\")\n\n    # Configura\u00e7\u00e3o da interface\n    font = pygame.font.SysFont(\"Arial\", 24)\n    input_handler = InputHandler(config_parser)\n\n    # Inicializa\u00e7\u00e3o do rel\u00f3gio\n    clock = pygame.time.Clock()\n    running = True\n    game_time = 0\n\n    # Ciclo principal\n    while running:\n        # Calcula o delta time\n        delta_time = clock.tick(60) / 1000.0\n        game_time += delta_time * 1000  # Converte para milissegundos\n\n        # Processa eventos\n        input_handler.process_events()\n        if input_handler.quit_game:\n            running = False\n\n        # Atualiza o jogo\n        game.update(delta_time, input_handler)\n\n        # Limpa a tela\n        game.screen.fill((0, 0, 0))\n\n        # Renderiza o jogo\n        game.render(game.screen)\n\n        # Renderiza informa\u00e7\u00f5es de depura\u00e7\u00e3o\n        render_fps(clock.get_fps(), game.screen, font)\n        time_text = font.render(f\"Tempo: {format_time(game_time)}\", True, (255, 255, 255))\n        game.screen.blit(time_text, (10, 40))\n\n        # Atualiza a tela\n        pygame.display.update()\n</code></pre> <p>Este exemplo expandido mostra como v\u00e1rias fun\u00e7\u00f5es utilit\u00e1rias trabalham juntas no ciclo principal do jogo.</p>"},{"location":"utils/#extendendo-as-funcoes-utilitarias","title":"Extendendo as Fun\u00e7\u00f5es Utilit\u00e1rias","text":"<p>O sistema de utilit\u00e1rios do 2Do \u00e9 projetado para ser facilmente expandido. Voc\u00ea pode adicionar suas pr\u00f3prias fun\u00e7\u00f5es auxiliares ao arquivo <code>utils.py</code> para atender \u00e0s necessidades espec\u00edficas do seu jogo.</p>"},{"location":"utils/#exemplos-de-extensoes-uteis","title":"Exemplos de Extens\u00f5es \u00dateis","text":""},{"location":"utils/#salvamento-automatico-de-configuracoes","title":"Salvamento Autom\u00e1tico de Configura\u00e7\u00f5es","text":"<pre><code>def save_config_file(config_parser, config_path):\n    \"\"\"\n    Salva as configura\u00e7\u00f5es atuais em um arquivo .ini\n\n    Args:\n        config_parser (configparser.ConfigParser): Parser com as configura\u00e7\u00f5es\n        config_path (str): Caminho para o arquivo de configura\u00e7\u00e3o\n    \"\"\"\n    try:\n        with open(config_path, 'w') as config_file:\n            config_parser.write(config_file)\n        print(f\"Configura\u00e7\u00f5es salvas em {config_path}\")\n    except Exception as e:\n        print(f\"Erro ao salvar configura\u00e7\u00f5es: {e}\")\n</code></pre> <p>Esta fun\u00e7\u00e3o permite salvar as configura\u00e7\u00f5es atuais, \u00fatil para preservar as prefer\u00eancias do jogador.</p>"},{"location":"utils/#carregamento-de-recursos-genericos","title":"Carregamento de Recursos Gen\u00e9ricos","text":"<pre><code>def load_image(path, convert_alpha=True):\n    \"\"\"\n    Carrega uma imagem com tratamento de erros\n\n    Args:\n        path (str): Caminho para o arquivo de imagem\n        convert_alpha (bool): Se deve converter a imagem para formato com transpar\u00eancia\n\n    Returns:\n        pygame.Surface: Imagem carregada ou None se falhar\n    \"\"\"\n    try:\n        if convert_alpha:\n            return pygame.image.load(path).convert_alpha()\n        else:\n            return pygame.image.load(path).convert()\n    except Exception as e:\n        print(f\"Erro ao carregar imagem {path}: {e}\")\n        return None\n</code></pre> <p>Esta fun\u00e7\u00e3o padroniza o carregamento de imagens com tratamento adequado de erros.</p>"},{"location":"utils/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Agora que voc\u00ea compreende as fun\u00e7\u00f5es utilit\u00e1rias do 2Do, pode explorar:</p> <ul> <li>L\u00f3gica de Jogo e Jogador - Como a l\u00f3gica central do jogo utiliza estes utilit\u00e1rios</li> <li>Configura\u00e7\u00e3o e Setup - Mais detalhes sobre o sistema de configura\u00e7\u00e3o</li> <li>Plano de Fundo e Interface - Como o sistema de fundo usa as utilidades</li> </ul>"}]}